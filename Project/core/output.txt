=== TheDungeonCrawl ===
package com.tdcrawl.tdc;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.utils.GdxNativesLoader;
import com.tdcrawl.tdc.events.CustomEvents;
import com.tdcrawl.tdc.items.Items;
import com.tdcrawl.tdc.objects.Objects;
import com.tdcrawl.tdc.screens.GameScreen;
import com.tdcrawl.tdc.util.Reference;

public class TheDungeonCrawl extends Game
{
	static // Runs before anything else (even main method)
	{
	    GdxNativesLoader.load();
	}
	
	@Override
	public void create()
	{
		CustomEvents.registerAll();
		Items.registerAll();
		Objects.registerAll();
		
		try
		{
			setScreen(new GameScreen());
		}
		catch (Exception ex)
		{
			Reference.handleError(ex);
		}
	}
}

=== CustomEvents ===
package com.tdcrawl.tdc.events;

public class CustomEvents
{
	public static final String 
		WORLD_LOCK_CHANGE_EVENT = "onWorldLockChange",
		ON_GAMEOBJECT_COLLISION = "onCollide";
	
	/**
	 * Registers all the events in the main game
	 */
	public static void registerAll()
	{
		EventsHandler.registerEvent(WORLD_LOCK_CHANGE_EVENT);
		EventsHandler.registerEvent(ON_GAMEOBJECT_COLLISION);
	}
}

=== Event ===
package com.tdcrawl.tdc.events;

public abstract class Event
{
	private boolean cancelled = false;
	
	/**
	 * Sets whether an object is cancelled or not
	 * @param c If it is cancelled
	 */
	public void setCancelled(boolean c)
	{
		if(isCancellable())
			this.cancelled = c;
	}
	
	// Getters & Setters //
	
	/**
	 * If an event is cancelled and is cancellable, the action that caused the event to be fired should be reverted
	 * @return if the event was cancelled
	 */
	public boolean isCancelled() { return cancelled; }
	
	public abstract boolean isCancellable();
	public abstract String getId();
}

=== EventCallback ===
package com.tdcrawl.tdc.events;

public interface EventCallback
{
	/**
	 * Called whenever a certain event happens by all its subscribers
	 * @param e The event that was executed
	 */
	public void callback(Event e);
}

=== EventsHandler ===
package com.tdcrawl.tdc.events;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.tdcrawl.tdc.exceptions.UnregisteredEventException;

public class EventsHandler
{
	/**
	 * Holds all the event id's and their subscribers
	 */
	private static Map<String, List<EventCallback>> subscribers = new HashMap<>();
	
	/**
	 * Calls an event so all its subscribers can react to it
	 * @param e The event object to pass to the subscribers
	 */
	public static void call(Event e)
	{
		List<EventCallback> subs = subscribers.get(e.getId()); 
		
		// If subs == null, this event was never registered so throw an exception to prevent logic errors
		if(subs == null)
			throw new UnregisteredEventException(e.getId() + " is an unregistered event!");
		
		for(EventCallback c : subs)
			c.callback(e);
	}
	
	/**
	 * Registers an event with the EventsHandler for later use
	 * @param eventId What the event should be called
	 * @return false if that is already registered, true if it was successfully registered
	 */
	public static boolean registerEvent(String eventId)
	{
		if(subscribers.containsKey(eventId))
			return false;
		
		subscribers.put(eventId, new ArrayList<EventCallback>());
		return true;
	}
	
	/**
	 * Whenever an event with the eventId given is called, the callback will be executed
	 * @param eventId The event to listen for
	 * @param callback What to execute when this event is called
	 */
	public static void subscribe(String eventId, EventCallback callback)
	{
		List<EventCallback> subs = subscribers.get(eventId);
		
		if(subs == null)
			throw new UnregisteredEventException(eventId + " is an unregistered event!");
		
		subs.add(callback);
	}
}

=== CollisionEvent ===
package com.tdcrawl.tdc.events.types;

import com.tdcrawl.tdc.events.CustomEvents;
import com.tdcrawl.tdc.events.Event;
import com.tdcrawl.tdc.objects.GameObject;
import com.tdcrawl.tdc.objects.fixtures.ObjectFixture;

public class CollisionEvent extends Event
{
	public static enum CollisionState
	{
		BEGIN_COLLISION,
		END_COLLISION
	}
	
	private CollisionState state;
	private GameObject obj1, obj2;
	private ObjectFixture fix1, fix2;
	
	/**
	 * Called whenever an object collides with another.
	 * Note: This will be called twice per collision, with the objects in question switched in the argument order
	 * @param obj1 The first object in the collision
	 * @param obj2 The second object in the collision
	 * @param fix1 The actual fixture that touched from obj1
	 * @param fix2 The actual fixture that touched from obj2
	 */
	public CollisionEvent(GameObject obj1, GameObject obj2, ObjectFixture fix1, ObjectFixture fix2, CollisionState state)
	{
		this.obj1 = obj1;
		this.obj2 = obj2;
		
		this.fix1 = fix1;
		this.fix2 = fix2;
		
		this.state = state;
	}
	
	// Getters & Setters //
	
	public GameObject getObject1() { return obj1; }
	public GameObject getObject2() { return obj2; }
	
	public ObjectFixture getFixture1() { return fix1; }
	public ObjectFixture getFixture2() { return fix2; }
	
	public CollisionState getState() { return state; }
	
	@Override
	public boolean isCancellable() { return false; }
	
	@Override
	public String getId() { return CustomEvents.ON_GAMEOBJECT_COLLISION; }
}

=== WorldLockChangeEvent ===
package com.tdcrawl.tdc.events.types;

import com.tdcrawl.tdc.events.CustomEvents;
import com.tdcrawl.tdc.events.Event;

public class WorldLockChangeEvent extends Event
{
	private boolean locked;
	
	/**
	 * Whenever the world is unlocked or locked, this event is called
	 * @param locked Whether or not the world is locked or unlocked
	 */
	public WorldLockChangeEvent(boolean locked)
	{
		this.locked = locked;
	}
	
	public boolean isLocked() { return locked; }
	
	@Override
	public boolean isCancellable() { return false; }
	
	@Override
	public String getId() { return CustomEvents.WORLD_LOCK_CHANGE_EVENT; }
}

=== UnregisteredEventException ===
package com.tdcrawl.tdc.exceptions;

public class UnregisteredEventException extends RuntimeException
{
	/**
	 * Eclipse generated ID
	 */
	private static final long serialVersionUID = 5607789355554706913L;
	
	private String message;
	
	/**
	 * Thrown whenever an unregistered event is referenced
	 */
	public UnregisteredEventException()
	{
		this("Event unregistered!");
	}
	
	/**
	 * Thrown whenever an unregistered event is referenced
	 * @param message What to say
	 */
	public UnregisteredEventException(String message)
	{
		this.message = message;
	}
	
	@Override
	public String getMessage() { return message; }
}

=== Item ===
package com.tdcrawl.tdc.items;

import com.badlogic.gdx.graphics.Camera;
import com.badlogic.gdx.math.Vector2;
import com.tdcrawl.tdc.objects.entities.living.LivingEntity;

public abstract class Item
{
	/**
	 * Returns the dimensions for the item when someone will hold them (assuming no scaling)
	 * @return The dimensions for the item when someone will hold them (assuming no scaling)
	 */
	public abstract Vector2 getDimensions();
	
	/**
	 * Called whenever a living entity tries to hold the object
	 * @return true if they can hold it, false if not
	 */
	public boolean onHold(LivingEntity e) { return true; }
	
	/**
	 * Called every time the holder ticks AND is holding the item
	 * @param delta The time passed since last update
	 * @param cam The camera used to render where the holder is
	 */
	public void tick(float delta, Camera cam) {}
	
	/**
	 * Called whenever the item should be used
	 * @param by Who it was used by
	 * @param on Whom it was used on OR the same as by if it is being used on the caster
	 * @param type The type of use
	 */
	public abstract void use(LivingEntity by, LivingEntity on, UseType type);
	
	public enum UseType
	{
		LEFT_CLICK,
		RIGHT_CLICK,
		MIDDLE_CLICK
	}
}

=== Items ===
package com.tdcrawl.tdc.items;

import com.tdcrawl.tdc.items.items.TestItem;
import com.tdcrawl.tdc.registries.ItemRegistry;

/**
 * A class for registering all the items
 */
public class Items
{
	/**
	 * Registers all the objects in the core game
	 */
	public static void registerAll()
	{
		ItemRegistry.registerObject("testItem", new TestItem.TestItemTemplate());
	}
}

=== Inventory ===
package com.tdcrawl.tdc.items.inventory;

import com.tdcrawl.tdc.items.Item;

public interface Inventory
{
	/**
	 * Gets how many items are currently in the invenory
	 * @return How many items are currently in the invenory
	 */
	public int getItemCount();
	
	/**
	 * Returns every item in the inventory as an Item array
	 * @return Every item in the inventory as an Item array
	 */
	public Item[] getItems();
	
	/**
	 * Sets the items of the inventory
	 * @throws IndexOutOfBoundsException if the items provided length is outside of the appropriate inventory size
	 * @param items The items to set
	 */
	public void setItems(Item[] items) throws IndexOutOfBoundsException;
	
	/**
	 * Gets an item at the item slot's index
	 * @param i The index to grab it at
	 */
	public Item getItemAt(int i);
	
	/**
	 * Returns the index of an item in the inventory based off slot indexes, or -1 if not present
	 * @param i The item to search for
	 * @return The index of an item in the inventory based off slot indexes, or -1 if not present
	 */
	public int getIndexOf(Item item);
	
	/**
	 * Checks if the inventory contains a given item (regardless of number of items)
	 * @param i The item to check for
	 * @return True if it contains it, false if not
	 */
	public boolean containsItem(Item item);
	
	/**
	 * Removes all items in the inventory
	 */
	public void clear();
	
	/**
	 * Returns how many items the inventory can hold, or -1 for an infinite amouht
	 * @return Returns how many items the inventory can hold, or -1 for an infinite amount
	 */
	public int size();
}

=== PlayerInventory ===
package com.tdcrawl.tdc.items.inventory;

import com.tdcrawl.tdc.items.Item;
import com.tdcrawl.tdc.items.items.healing.HealingItem;
import com.tdcrawl.tdc.items.items.weapons.melee.MeleeWeapon;
import com.tdcrawl.tdc.items.items.weapons.ranged.RangedWeapon;

public class PlayerInventory implements Inventory
{
	private Item[] items;
	
	public PlayerInventory()
	{
		items = new Item[3];
	}
	
	public PlayerInventory(MeleeWeapon m, RangedWeapon r, HealingItem h)
	{
		items = new Item[]{m, r, h};
	}
	
	@Override
	public int getItemCount()
	{
		int count = 0;
		
		for(int i = 0; i < items.length; i++)
		{
			if(items[i] != null)
			{
				count++;
			}
		}
		
		return count;
	}

	@Override
	public Item[] getItems()
	{
		return items;
	}

	@Override
	public void setItems(Item[] items) throws IndexOutOfBoundsException
	{
		this.items = items;
	}

	@Override
	public Item getItemAt(int i)
	{
		return items[i];
	}

	@Override
	public int getIndexOf(Item item)
	{
		for(int i = 0; i < items.length; i++)
		{
			if(item.equals(items[i]))
			{
				return i;
			}
		}
		
		return -1;
	}

	@Override
	public boolean containsItem(Item i)
	{
		return getIndexOf(i) != -1;
	}

	@Override
	public void clear()
	{
		items = new Item[3];
	}

	@Override
	public int size()
	{
		return items.length;
	}

}

=== TestItem ===
package com.tdcrawl.tdc.items.items;

import com.badlogic.gdx.math.Vector2;
import com.tdcrawl.tdc.items.Item;
import com.tdcrawl.tdc.objects.entities.living.LivingEntity;
import com.tdcrawl.tdc.registries.templates.ItemData;
import com.tdcrawl.tdc.registries.templates.ItemTemplate;

public class TestItem extends Item
{
	@Override
	public Vector2 getDimensions()
	{
		return new Vector2(0.05f, 0.3f);
	}

	@Override
	public void use(LivingEntity by, LivingEntity on, UseType type)
	{
		System.out.print("Item Used (");
		
		switch(type)
		{
			case LEFT_CLICK:
				System.out.print("left click");
				break;
			case RIGHT_CLICK:
				System.out.print("right click");
				break;
			case MIDDLE_CLICK:
				System.out.print("middle click");
				break;
		}
		
		System.out.println(")!");
	}
	
	public static class TestItemTemplate implements ItemTemplate
	{
		@Override
		public Item create(ItemData data)
		{
			return new TestItem();
		}
	}
}

=== HealingItem ===
package com.tdcrawl.tdc.items.items.healing;

import com.tdcrawl.tdc.items.Item;
import com.tdcrawl.tdc.objects.entities.living.LivingEntity;

public abstract class HealingItem extends Item
{
	private int healingValue;
	private int passiveHeal;
	
	public HealingItem(int h, int p)
	{
		healingValue = h;
		passiveHeal = p;
	}
	
	@Override
	/**
	 * Called whenever the item should be used
	 * @param by Who it was used by
	 * @param on Whom it was used on OR the same as by if it is being used on the caster
	 * @param type The type of use
	 */
	public void use(LivingEntity by, LivingEntity on, UseType type)
	{
		if(type.equals(UseType.RIGHT_CLICK))
		{
			by.heal(healingValue);
		}
	}
	
	public int getPassiveHeal()
	{
		return passiveHeal;
	}
}
	

=== Weapon ===
package com.tdcrawl.tdc.items.items.weapons;

import com.tdcrawl.tdc.items.Item;

public abstract class Weapon extends Item
{
	private int damage;
	
	public Weapon(int d)
	{
		damage = d;
	}
	
	public int getDamage() {return damage;}
	public void setDamage(int d) {damage = d;}
}

=== MeleeWeapon ===
package com.tdcrawl.tdc.items.items.weapons.melee;

import com.tdcrawl.tdc.items.items.weapons.Weapon;

public abstract class MeleeWeapon extends Weapon
{
	public MeleeWeapon(int d)
	{
		super(d);
	}
}

=== Sword ===
package com.tdcrawl.tdc.items.items.weapons.melee;

import com.badlogic.gdx.math.Vector2;
import com.tdcrawl.tdc.items.Item;
import com.tdcrawl.tdc.items.items.TestItem;
import com.tdcrawl.tdc.objects.entities.living.LivingEntity;
import com.tdcrawl.tdc.registries.templates.ItemData;
import com.tdcrawl.tdc.registries.templates.ItemTemplate;

public class Sword extends MeleeWeapon
{

	public Sword()
	{
		super(5);
	}

	@Override
	public Vector2 getDimensions()
	{
		return new Vector2(0.15f, 0.4f);
	}

	@Override
	public void use(LivingEntity by, LivingEntity on, UseType type)
	{
		on.takeDamage(getDamage());
	}

	public static class TestItemTemplate implements ItemTemplate
	{
		@Override
		public Item create(ItemData data)
		{
			return new TestItem();
		}
	}
}

=== RangedWeapon ===
package com.tdcrawl.tdc.items.items.weapons.ranged;

import com.tdcrawl.tdc.items.items.weapons.Weapon;
import com.tdcrawl.tdc.objects.entities.living.LivingEntity;

public abstract class RangedWeapon extends Weapon
{
	public RangedWeapon(int d)
	{
		super(d);
	}
	
	@Override
	/**
	 * Called whenever the item should be used
	 * @param by Who it was used by
	 * @param on Whom it was used on OR the same as by if it is being used on the caster
	 * @param type The type of use
	 */
	public void use(LivingEntity by, LivingEntity on, UseType type)
	{
		if(type == UseType.RIGHT_CLICK)
		{
			
		}
	}
}

=== ObjectJoint ===
package com.tdcrawl.tdc.joints;

import com.badlogic.gdx.physics.box2d.Joint;
import com.badlogic.gdx.physics.box2d.JointDef;
import com.badlogic.gdx.physics.box2d.JointDef.JointType;

public class ObjectJoint
{
	/**
	 * This is initialized once the joint is initialized, and set to null when it is detached
	 */
	private Joint joint;
	
	private JointDef def;
	
	/**
	 * A simpler way of handling joints with GameObjects
	 * @param def The definition for the joint
	 */
	public ObjectJoint(JointDef def)
	{
		this.def = def;
	}
	
	/**
	 * Attaches the joint to the bodies specified in its definition, assuming they have been initialized
	 */
	public void attach()
	{
		if(def.bodyA != null && def.bodyB != null && !attached())
			joint = getDefinition().bodyA.getWorld().createJoint(getDefinition());
		else
			throw new IllegalStateException("Cannot add a part to an uninitialized object!");
	}
	
	/**
	 * Removes the joint from the bodies specified in its definition
	 */
	public void detatch()
	{
		if(attached())
			getDefinition().bodyA.getWorld().destroyJoint(getJoint());
		
		joint = null;
	}
	
	public boolean attached() { return joint != null; }
	public JointDef getDefinition() { return def; }
	public Joint getJoint() { return joint; }
	public JointType getJointType() { return joint.getType(); }
}

=== Level ===
package com.tdcrawl.tdc.levels;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.badlogic.gdx.graphics.Camera;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.physics.box2d.Box2DDebugRenderer;
import com.badlogic.gdx.physics.box2d.World;
import com.google.gson.Gson;
import com.tdcrawl.tdc.events.CustomEvents;
import com.tdcrawl.tdc.events.Event;
import com.tdcrawl.tdc.events.EventCallback;
import com.tdcrawl.tdc.events.EventsHandler;
import com.tdcrawl.tdc.events.types.WorldLockChangeEvent;
import com.tdcrawl.tdc.levels.rooms.Room;
import com.tdcrawl.tdc.levels.rooms.RoomBuilder;
import com.tdcrawl.tdc.objects.entities.living.Player;
import com.tdcrawl.tdc.physics.DefaultCollisionHandler;
import com.tdcrawl.tdc.util.Helper;
import com.tdcrawl.tdc.util.Reference;
import com.tdcrawl.tdc.util.Vector2I;

/**
 * Stores all the rooms of a given level and handles their generation
 */
public class Level
{
	private Room[][] rooms;
	private List<RoomBuilder> roomTypes = new ArrayList<>();	
	private RoomBuilder spawnRoom;
	
	private final int FLOOR_NUMBER;
	
	private final String name;
	private final Vector2I roomAmountXY;
	private final Vector2 roomDimensions;
	
	/**
	 * Where every object will be
	 */
	private World world;
	
	/**
	 * This is the player
	 */
	private Player player;
	
	/**
	 * Creates the world and loads the room variations
	 * @throws IOException If there is an error reading the room variations
	 */
	public Level(int floorNo) throws IOException
	{
		FLOOR_NUMBER = floorNo;
		
		Reference.debugLog("Loading floor #" + floorNo + ".", this);
		
		Gson gson = new Gson();
		LevelTemplate t = gson.fromJson(new FileReader(getFloorFolder() + "level.json"), LevelTemplate.class);
		
		this.roomAmountXY = t.roomAmountXY;
		this.name = t.name;
		this.roomDimensions = t.roomDimensions;
		
		world = new World(new Vector2(0, -9.8f), true);
		
		// Handles any collision events that happen in the world
		world.setContactListener(new DefaultCollisionHandler());
		
		init();
	}
	
	/**
	 * Assembles a randomly generated level based off the room variations loaded before
	 */
	public void create()
	{
		float yOffset = 0;
		float xOffset = 0;
		
		float maxOffsetY = 0;
		
		rooms = new Room[roomAmountXY.y * 2][roomAmountXY.x * 2];
		
		for(int y = 0; y < 2 * roomAmountXY.y; y++)
		{
			for(int x = 0; x < 2 * roomAmountXY.x; x++)
			{
				Room r;
				
				boolean leftBorder = x == 0,
						rightBorder = x == roomAmountXY.x * 2 - 1, 
						topBorder = y == 0,
						bottomBorder = y == roomAmountXY.y * 2 - 1;
				
				if(x == roomAmountXY.x && y == roomAmountXY.y)
					r = spawnRoom.createRoom(this, new Vector2(xOffset, yOffset), leftBorder, rightBorder, topBorder, bottomBorder);
				else
					r = roomTypes.get((int)(Math.random() * roomTypes.size())).createRoom(this, new Vector2(xOffset, yOffset), leftBorder, rightBorder, topBorder, bottomBorder);
				
				xOffset += r.getDimensions().x;
				maxOffsetY = Math.max(r.getDimensions().y, maxOffsetY);
				
				r.init();
				
				rooms[y][x] = r;
			}
			
			xOffset = 0;
			yOffset += maxOffsetY;
		}
	}
	
	/**
	 * Loads all the rooms from the floor's folder
	 * @throws IOException If there is an error reading those room files
	 */
	private void init() throws IOException
	{
		int i = 0; // Each room number
		
		File f = new File(getFloorFolder() + roomName(i));
		
		// Keep going until we run out of room types
		while (f.exists())
		{
			roomTypes.add(getRoomBuilder(f));
			
			i++;
			f = new File(getFloorFolder() + roomName(i));
		}
		
		f = new File(getFloorFolder() + "room-spawn.json");
		
		if(!f.exists())
			throw new IllegalStateException("No spawn room for floor " + FLOOR_NUMBER + "!");
		
		spawnRoom = getRoomBuilder(f);
		
		EventsHandler.subscribe(CustomEvents.WORLD_LOCK_CHANGE_EVENT, new EventCallback()
		{
			@Override
			public void callback(Event e)
			{
				WorldLockChangeEvent event = (WorldLockChangeEvent)e;
				
				if(!event.isCancelled() && !event.isLocked())
				{
					Helper.cleanup();
				}
			}
		});
	}
	
	/**
	 * Loads and creates a RoomBuilder from a file with RoomBuilder json
	 * @param f The file to load the json from
	 * @return The RoomBuilder generated from the json in the file
	 * @throws IOException If there is an error reading the room file
	 */
	private RoomBuilder getRoomBuilder(File f) throws IOException
	{
		StringBuilder lines = new StringBuilder();
		BufferedReader br = new BufferedReader(new FileReader(f));
		for(String line = br.readLine(); line != null; line = br.readLine())
		{
			lines.append(line);
		}
		br.close();
		
		// Creates the room builder to later build the room once create() is called
		RoomBuilder builder = new RoomBuilder();
		builder.createFromJSON(lines.toString());
		
		return builder;
	}
	
	private String roomName(int i)
	{
		return "room_" + i + ".json";
	}
	
	private String getFloorFolder()
	{
		return "assets/levels/floor-" + FLOOR_NUMBER + "/";
	}
	
	public void tick(float delta, Camera camera)
	{
		Helper.setWorldLocked(true);
		world.step(delta, 8, 3); // 8 and 3 are good* values I found online. *I assume they are good.
		// URL: http://www.iforce2d.net/b2dtut/worlds
		
		for(int y = 0; y < rooms.length; y++)
		{
			for(int x = 0; x < rooms[y].length; x++)
			{
				Room room = rooms[y][x];
				
				if(getPlayer() != null)
				{
					if(getPlayer().getPosition().x > x * getRoomDimensions().x && getPlayer().getPosition().x < (x + 1) * getRoomDimensions().x
							&& getPlayer().getPosition().y > y * getRoomDimensions().y && getPlayer().getPosition().y < (y + 1) * getRoomDimensions().y)
					{
						if(!getPlayer().getRoom().equals(room))
						{
							getPlayer().getRoom().removeObject(getPlayer());
							getPlayer().setRoom(room);
							room.addObject(getPlayer());
						}
					}
				}
				
				room.tick(delta, camera);
			}
		}
		Helper.setWorldLocked(false);
	}
	
	public void render(float delta, Camera cam, Box2DDebugRenderer debugRenderer)
	{
		if(player != null)
			cam.position.lerp(new Vector3(player.getPosition(), 0), 0.1f);
		cam.update();
		
		if(Reference.isDebug() && debugRenderer != null)
			debugRenderer.render(world, cam.combined);
	}
	
	public void dispose()
	{
		world.dispose();
	}
	
	// Getters & Setters //
	
	public World getWorld() { return world; }
	
	public String getName() { return name; }

	public Vector2 getRoomDimensions() { return roomDimensions.cpy(); }

	public void setPlayer(Player player) { this.player = player; }
	public Player getPlayer() { return player; }
}

=== LevelTemplate ===
package com.tdcrawl.tdc.levels;

import com.badlogic.gdx.math.Vector2;
import com.tdcrawl.tdc.util.Vector2I;

public class LevelTemplate
{
	public String name;
	public Vector2I roomAmountXY;
	public Vector2 roomDimensions;
}

=== Room ===
package com.tdcrawl.tdc.levels.rooms;

import java.util.ArrayList;
import java.util.List;

import com.badlogic.gdx.graphics.Camera;
import com.badlogic.gdx.math.Vector2;
import com.tdcrawl.tdc.levels.Level;
import com.tdcrawl.tdc.objects.GameObject;
import com.tdcrawl.tdc.objects.entities.Door;
import com.tdcrawl.tdc.objects.entities.Entity;
import com.tdcrawl.tdc.objects.entities.living.LivingEntity;
import com.tdcrawl.tdc.objects.entities.living.Player;
import com.tdcrawl.tdc.objects.entities.living.types.EntityType;
import com.tdcrawl.tdc.util.Helper;

/**
 * Just a thing that stores a bunch of GameObjects
 */
public class Room
{
	private Level level;
	
	private boolean isOpen = true;
	
	private List<GameObject> objectsInRoom = new ArrayList<>();
	private List<Entity> entitiesInRoom = new ArrayList<>();
	private List<LivingEntity> thingsToSpawn = new ArrayList<>();
	
	private Player player = null;
	
	public Room(Level level)
	{
		this.level = level;
	}
	
	public void tick(float delta, Camera cam)
	{
		if(thingsToSpawn.size() != 0)
		{
			if(getPlayer() != null)
			{
				initiateRoom();
			}
		}
		
		List<LivingEntity> dead = new ArrayList<>();
		
		for(Entity e : entitiesInRoom)
		{
			e.tick(delta, cam);
			
			if(e instanceof LivingEntity)
			{
				LivingEntity living = (LivingEntity)e;
				if(living.getHealth() <= 0)
					if(living.die())
						dead.add(living);
			}
		}
		
		while(dead.size() != 0)
		{
			System.out.println("AYE ADDED");
			LivingEntity deadBoi = dead.remove(dead.size() - 1);
			removeObject(deadBoi);
			Helper.removeObject(deadBoi);
		}
		
		if(isPlayerIn() && !isOpen)
		{
			for(Entity e : entitiesInRoom)
			{
				if(e instanceof LivingEntity)
				{
					if(((LivingEntity)e).getEntityType() == EntityType.HOSTILE)
					{
						isOpen = true; // Inverts it after loop
						break;
					}
				}
			}
			
			// If no hostiles were found, this would be false so invert it to true, and if a hostile was found this would be true so invert it to false
			setOpen(!isOpen);
		}
	}
	
	private void setOpen(boolean isOpen)
	{
		this.isOpen = isOpen;
		
		for(GameObject obj : objectsInRoom)
		{
			if(obj instanceof Door)
			{
				((Door)obj).setOpen(isOpen);
			}
		}
	}
	
	public void initiateRoom()
	{
		if(thingsToSpawn.size() != 0)
			setOpen(false);
		else
			setOpen(true);
		
		for(LivingEntity ent : thingsToSpawn)
		{
			addObject(ent, true);
			
			if(ent.getBody() == null)
				ent.init(level.getWorld());
		}
		
		thingsToSpawn.clear();
	}
	
	public void init()
	{
		boolean spawnRoom = false;
		
		for(LivingEntity e : thingsToSpawn)
		{
			if(e instanceof Player)
			{
				spawnRoom = true;
				level.setPlayer((Player)e);
			}
		}
		
		for(GameObject o : getObjectsInRoom())
		{
			o.init(level.getWorld());
		}
		
		if(spawnRoom)
		{
			initiateRoom();
		}
	}
	
	// Getters & Setters //

	public List<GameObject> getObjectsInRoom() { return objectsInRoom; }
	public List<Entity> getEntitiesInRoom() { return entitiesInRoom; }
	
	public void addObject(GameObject obj)
	{
		addObject(obj, false);
	}
	
	private void addObject(GameObject obj, boolean ignoreClosed)
	{
		if(obj instanceof Player)
			setPlayer((Player)obj);
		
		if((isOpen || !ignoreClosed) && obj instanceof LivingEntity)
		{
			thingsToSpawn.add((LivingEntity)obj);
		}
		else
		{
			objectsInRoom.add(obj);
			if(obj instanceof Entity)
				entitiesInRoom.add((Entity)obj);
		}
	}
	
	public void removeObject(GameObject obj)
	{
		objectsInRoom.remove(obj);
		if(obj instanceof Entity)
		{
			entitiesInRoom.remove((Entity)obj);
			
			if(obj instanceof LivingEntity)
			{
				if(((LivingEntity)obj).getEntityType() == EntityType.HOSTILE)
				{
					boolean shouldOpen = true;
					for(Entity e : entitiesInRoom)
					{
						if(e instanceof LivingEntity && ((LivingEntity)e).getEntityType() == EntityType.HOSTILE)
						{
							shouldOpen = false;
							break;
						}
					}
					
					setOpen(shouldOpen);
				}
			}
		}
	}
	
	public Vector2 getDimensions() { return level.getRoomDimensions(); }
	
	public void playerEnter(Player p) { this.player = p; }
	public void playerLeave() { this.player = null; }
	public boolean isPlayerIn() { return player != null; }
	public Player getPlayer() { return player; }
	private void setPlayer(Player p) { this.player = p; }
}

=== RoomBlueprint ===
package com.tdcrawl.tdc.levels.rooms;

import java.util.List;

import com.tdcrawl.tdc.registries.templates.ObjectData;

/**
 * This class will instruct GSON on how to properly read and save room Json files
 */
public class RoomBlueprint
{
	public boolean enclosed = true;
	public List<ObjectData> objects;
}

=== RoomBuilder ===
package com.tdcrawl.tdc.levels.rooms;

import java.util.ArrayList;
import java.util.List;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.PolygonShape;
import com.google.gson.Gson;
import com.tdcrawl.tdc.levels.Level;
import com.tdcrawl.tdc.objects.GameObject;
import com.tdcrawl.tdc.objects.entities.Door;
import com.tdcrawl.tdc.objects.entities.Entity;
import com.tdcrawl.tdc.objects.staticobjects.Platform;
import com.tdcrawl.tdc.registries.ObjectRegistry;
import com.tdcrawl.tdc.registries.templates.ObjectData;
import com.tdcrawl.tdc.registries.templates.ObjectTemplate;

public class RoomBuilder
{
	private boolean enclosed;
	
	// These are parallel
	private List<ObjectTemplate> templates = new ArrayList<>();
	private List<ObjectData> templatesData = new ArrayList<>();
	
	/**
	 * Creates the RoomBuilder from json
	 * @param json The json to create it from
	 */
	public void createFromJSON(String json)
	{
		Gson gson = new Gson(); // This will parse json
		
		RoomBlueprint blueprint = gson.fromJson(json, RoomBlueprint.class);
		
		templates.clear();
		templatesData.clear();
		
		// Adds all the objects created fromt he object data to add to the room when we create the room
		for(ObjectData data : blueprint.objects)
		{
			ObjectTemplate template = ObjectRegistry.getObject(data.name);
			
			if(template != null)
			{
				templates.add(template);
				templatesData.add(data);
			}
			else
				throw new IllegalStateException("Bad object name \"" + data.name + "\".");
		}
		
		enclosed = blueprint.enclosed;
	}
	
	/**
	 * Creates a room and fills it up with the objects
	 * @param level the Level the room is a part of
	 * @return The room with all the objects in it
	 */
	public Room createRoom(Level level, boolean leftBorder, boolean rightBorder, boolean topBorder, boolean bottomBorder)
	{
		return createRoom(level, Vector2.Zero, leftBorder, rightBorder, topBorder, bottomBorder);
	}
	
	/**
	 * Creates a room and fills it up with the objects
	 * @param offset The offset of every object in the room
	 * @param level The level the room is a part of
	 * @return The room with all the objects in it
	 */
	public Room createRoom(Level level, Vector2 offset, boolean leftBorder, boolean rightBorder, boolean topBorder, boolean bottomBorder)
	{
		Room room = new Room(level);
		
		for(int i = 0; i < templates.size(); i++)
		{
			ObjectTemplate t = templates.get(i);
			
			GameObject o = t.create(templatesData.get(i).clone());
			
			o.getPosition().add(offset);
			
			room.addObject(o);
			if(o instanceof Entity)
				((Entity)o).setRoom(room);
		}
		
		if(enclosed)
		{
			final float gapWidth = 4f;
			
			Vector2 dimensions = room.getDimensions();
			
			float width = (dimensions.x - gapWidth) / 2;
			float height = (dimensions.y - gapWidth) / 2;
			float doorWidth = dimensions.x - width * 2;
			float doorHeight = dimensions.y - height * 2;
			
			float thickness = 0.25f;
			float platformWidth = width / 2;
			float platformHeight = height / 2;
			
			// Floor
			PolygonShape floorShape1 = new PolygonShape();
			floorShape1.setAsBox(platformWidth, thickness);
			Platform floorPlatform1 = new Platform(floorShape1, new Vector2(platformWidth, 0).add(offset), 1.0f, 0.0f);
			
			PolygonShape floorShape2 = new PolygonShape();
			floorShape2.setAsBox(platformWidth, thickness);
			Platform floorPlatform2 = new Platform(floorShape2, new Vector2(dimensions.x - platformWidth, 0).add(offset), 1.0f, 0.0f);
			
			Door floorDoor = new Door(new Vector2(dimensions.x / 2, dimensions.y).add(offset), new Vector2(thickness, doorWidth / 2), (float)Math.PI / 2.0f, doorWidth / 2);
			floorDoor.setLocked(bottomBorder);
			
			room.addObject(floorDoor);
			room.addObject(floorPlatform1);
			room.addObject(floorPlatform2);
			
			// Ceiling
			PolygonShape ceilingShape1 = new PolygonShape();
			ceilingShape1.setAsBox(platformWidth, thickness);
			Platform ceilingPlatform1 = new Platform(ceilingShape1, new Vector2(platformWidth, dimensions.y).add(offset), 1.0f, 0.0f);
			
			PolygonShape ceilingShape2 = new PolygonShape();
			ceilingShape2.setAsBox(platformWidth, thickness);
			Platform ceilingPlatform2 = new Platform(ceilingShape2, new Vector2(dimensions.x - platformWidth, dimensions.y).add(offset), 1.0f, 0.0f);
			
			Door ceilingDoor = new Door(new Vector2(dimensions.x / 2, 0).add(offset), new Vector2(thickness, doorWidth / 2), (float)Math.PI / 2.0f, doorWidth / 2);
			ceilingDoor.setLocked(topBorder);
			
			room.addObject(ceilingDoor);
			room.addObject(ceilingPlatform1);
			room.addObject(ceilingPlatform2);
			
			// Left wall
			PolygonShape leftWallShape1 = new PolygonShape();
			leftWallShape1.setAsBox(thickness, platformHeight);
			Platform leftWallPlatform1 = new Platform(leftWallShape1, new Vector2(0, platformHeight).add(offset), 1.0f, 0.0f);
			
			PolygonShape leftWallShape2 = new PolygonShape();
			leftWallShape2.setAsBox(thickness, platformHeight);
			Platform leftWallPlatform2 = new Platform(leftWallShape2, new Vector2(0, dimensions.y - platformHeight).add(offset), 1.0f, 0.0f);
			
			Door leftWallDoor = new Door(new Vector2(0, dimensions.y / 2).add(offset), new Vector2(thickness, doorHeight / 2), 0, doorHeight / 2);
			leftWallDoor.setLocked(leftBorder);
			
			room.addObject(leftWallPlatform1);
			room.addObject(leftWallPlatform2);
			room.addObject(leftWallDoor);
			
			// Right wall
			PolygonShape rightWallShape1 = new PolygonShape();
			rightWallShape1.setAsBox(thickness, platformHeight);
			Platform rightWallPlatform1 = new Platform(rightWallShape1, new Vector2(dimensions.x, platformHeight).add(offset), 1.0f, 0.0f);
			
			PolygonShape rightWallShape2 = new PolygonShape();
			rightWallShape2.setAsBox(thickness, platformHeight);
			Platform rightWallPlatform2 = new Platform(rightWallShape2, new Vector2(dimensions.y, dimensions.y - platformHeight).add(offset), 1.0f, 0.0f);
			
			Door rightWallDoor = new Door(new Vector2(dimensions.x, dimensions.y / 2).add(offset), new Vector2(thickness, doorHeight / 2), 0, doorHeight / 2);
			rightWallDoor.setLocked(rightBorder);
			
			room.addObject(rightWallDoor);
			room.addObject(rightWallPlatform1);
			room.addObject(rightWallPlatform2);
		}
		return room;
	}
}

=== GameObject ===
package com.tdcrawl.tdc.objects;

import java.util.ArrayList;
import java.util.List;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.BodyDef;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;
import com.badlogic.gdx.physics.box2d.Fixture;
import com.badlogic.gdx.physics.box2d.Shape;
import com.badlogic.gdx.physics.box2d.World;
import com.tdcrawl.tdc.objects.fixtures.ObjectFixture;
import com.tdcrawl.tdc.util.Helper;

/**
 * Stores fixtures to be added to the body (other than the center one) once it is initialized.
 */
public abstract class GameObject
{
	private Body body;
	private World world;
	private Fixture centralPoint;
	
	// This value will be updated
	private float density;
	
	private ObjectFixture centerFixture;
	
	// Once the object is initialized, this values are not updated. Use the getters and setters instead
	private BodyType type;
	private Vector2 position;
	private float angle;
	private boolean bullet, fixedRotation;
	private boolean collidable;
	
	/**
	 * Stores fixtures to be added to the body (other than the center one) once it is initialized.
	 */
	private List<ObjectFixture> fixturesToAdd = new ArrayList<>();
	
	/**
	 * Creates a game object with all the information needed to initialize it when ready
	 * @param shape The shape the object will have
	 * @param shape The shape the object will have
	 * @param position Where the object will be placed in the world
	 * @param type The BodyType of the object
	 * @param density How dense the object is
	 * @param restitution How bouncy the object is between 0 to 1.0f inclusive
	 * @param friction How much friction it has between 0 to 1.0f inclusive
	 * @param angle The angle of the body in radians
	 * @param bullet If the collision should be extra precise on this objects (used for really quick things)
	 * @param fixedRotation If rotation should be handled through physical interactions or just via programmatically setting it
	 * @param collidable If this has a solid collision box (true), or things will pass through it (false)
	 */
	public GameObject(Shape shape, Vector2 position, BodyType type, 
			float density, float restitution, float friction, float angle,
			boolean bullet, boolean fixedRotation, boolean collidable)
	{
		this(shape, position, type, density, restitution, friction, angle, bullet, fixedRotation, collidable, new Vector2(0, 0));
	}
	
	/**
	 * Creates a game object with all the information needed to initialize it when ready
	 * @param shape The shape the object will have
	 * @param position Where the object will be placed in the world
	 * @param type The BodyType of the object
	 * @param density How dense the object is
	 * @param restitution How bouncy the object is between 0 to 1.0f inclusive
	 * @param friction How much friction it has between 0 to 1.0f inclusive
	 * @param angle The angle of the body in radians
	 * @param bullet If the collision should be extra precise on this objects (used for really quick things)
	 * @param fixedRotation If rotation should be handled through physical interactions or just via programmatically setting it
	 * @param collidable If this has a solid collision box (true), or things will pass through it (false)
	 * @param centerPoint The fixture that will be added to the body as the base fixture (if null no fixture will be added)
	 */
	public GameObject(Shape shape, Vector2 position, BodyType type, 
			float density, float restitution, float friction, float angle,
			boolean bullet, boolean fixedRotation, boolean collidable, Vector2 centerPoint)
	{
		this(position, type, angle, bullet, fixedRotation, collidable, 
				new ObjectFixture(collidable, density, restitution, friction, shape, centerPoint));
	}
	
	/**
	 * Creates a game object with all the information needed to initialize it when ready
	 * @param position Where the object will be placed in the world
	 * @param type The BodyType of the object
	 * @param angle The angle of the object (degrees I think)
	 * @param bullet If the collision should be extra precise on this objects (used for really quick things)
	 * @param fixedRotation If rotation should be handled through physical interactions or just via programmatically setting it
	 * @param collidable If this has a solid collision box (true), or things will pass through it (false)
	 * @param centerFixture The fixture that will be added to the body as the base fixture (if null no fixture will be added)
	 */
	public GameObject(Vector2 position, BodyType type, float angle,
			boolean bullet, boolean fixedRotation, boolean collidable, ObjectFixture centerFixture)
	{
		this.position = position;
		this.type = type;
		this.bullet = bullet;
		this.angle = angle;
		this.fixedRotation = fixedRotation;
		this.collidable = collidable;
		this.centerFixture = centerFixture;
		if(centerFixture != null)
			this.density = centerFixture.getDensity();
	}
	
	/**
	 * Adds the GameObject and all its fixtures to the world
	 * @param world The world to add this to
	 */
	public void init(World world)
	{
		if(initialized())
			throw new IllegalStateException("This object has already been initialized!");
		
		this.world = world;
		
		BodyDef bodyDef = new BodyDef();
		bodyDef.allowSleep = true;
		bodyDef.angle = angle;
		bodyDef.bullet = bullet;
		bodyDef.fixedRotation = fixedRotation;
		bodyDef.type = type;
		
		body = world.createBody(bodyDef);
				
		if(centerFixture != null)
			centerFixture.init(getBody());
				
		while(fixturesToAdd.size() != 0)
			fixturesToAdd.remove(fixturesToAdd.size() - 1).init(getBody());
		
		body.setTransform(position, body.getAngle());
		
		// This allows me to see what object this belongs to later
		body.setUserData(this);
	}
	
	/**
	 * Appends a fixture to the object
	 * @param f The fixture to append
	 */
	public void addFixture(ObjectFixture f)
	{
		if(initialized())
		{
			if(centerFixture == null)
				centerFixture = f;
			Helper.addFixture(f, this);
		}
		else
		{
			if(centerFixture == null)
				centerFixture = f;
			else
				fixturesToAdd.add(f);
		}
	}
	
	public void removeFixture(ObjectFixture f)
	{
		if(initialized())
		{
			if(f.equals(centerFixture))
				centerFixture = null;
			
			Helper.removeFixture(f);
		}
		else
		{
			if(centerFixture.equals(f))
				centerFixture = null;
			else
				fixturesToAdd.remove(f);
		}
	}
	
	// Getters & Setters //
	
	protected void setShape(Shape shape)
	{
		centerFixture.setShape(shape);
	}
	
	public boolean initialized()
	{
		return body != null;
	}
	
	public World getWorld() { return world; }
	public Body getBody() { return body; }
	
	public Vector2 getPosition()
	{
		if(initialized())
			return body.getPosition();
		else
			return position;
	}
	
	public void setPosition(Vector2 position)
	{
		if(initialized())
			body.setTransform(position, getAngle());
		else
			this.position = position;
	}
	
	public float getAngle()
	{
		if(initialized())
			return body.getAngle();
		else
			return angle;
	}
	
	public void setAngle(float angle)
	{
		if(initialized())
			body.setTransform(getPosition(), angle);
		else
			this.angle = angle;
	}
	
	public BodyType getType()
	{
		if(initialized())
			return body.getType();
		else
			return type;
	}
	
	public boolean isCollidable()
	{
		if(initialized())
			return centralPoint.isSensor();
		else
			return collidable;
	}
	
	public void setCollidable(boolean collidable)
	{
		if(initialized())
			centralPoint.setSensor(!collidable);
		else
			this.collidable = collidable;
	}
	
	public boolean hasFixedRotation()
	{
		if(initialized())
			return body.isFixedRotation();
		else
			return fixedRotation;
	}
	
	public void setFixedRotation(boolean fixedRotation)
	{
		if(initialized())
			body.setFixedRotation(fixedRotation);
		else
			this.fixedRotation = fixedRotation;
	}
	
	public boolean isBullet()
	{
		if(initialized())
			return body.isBullet();
		else
			return bullet;
	}
	
	public void setBullet(boolean bullet)
	{
		if(initialized())
			body.setBullet(bullet);
		else
			this.bullet = bullet;
	}
	
	public void setBody(Body b) { body = b; }
	
	public float getDensity()
	{
		return density;
	}
	
	/**
	 * Sometimes works :/
	 * Tells if you are on the ground based off your Y velocity
	 * Since y velocity is almost never 0 if it's not on the ground, this works pretty much every time and is more efficient than checking for collision
	 * @return True if y velocity is 0, false if not
	 */
	public boolean isOnGround()
	{
		if(!initialized())
			return false;
		return this.getBody().getLinearVelocity().y == 0;
	}

	@Override
	/*
	 * Eclipse Generated
	 */
	public int hashCode()
	{
		final int prime = 31;
		int result = 1;
		result = prime * result + Float.floatToIntBits(angle);
		result = prime * result + ((body == null) ? 0 : body.hashCode());
		result = prime * result + (bullet ? 1231 : 1237);
		result = prime * result + ((centerFixture == null) ? 0 : centerFixture.hashCode());
		result = prime * result + ((centralPoint == null) ? 0 : centralPoint.hashCode());
		result = prime * result + (collidable ? 1231 : 1237);
		result = prime * result + Float.floatToIntBits(density);
		result = prime * result + (fixedRotation ? 1231 : 1237);
		result = prime * result + ((fixturesToAdd == null) ? 0 : fixturesToAdd.hashCode());
		result = prime * result + ((position == null) ? 0 : position.hashCode());
		result = prime * result + ((type == null) ? 0 : type.hashCode());
		return result;
	}

	@Override
	/*
	 * Eclipse Generated
	 */
	public boolean equals(Object obj)
	{
		if (this == obj)
			return true;
		if(!(obj instanceof GameObject))
			return false;
		GameObject other = (GameObject) obj;
		if (Float.floatToIntBits(angle) != Float.floatToIntBits(other.angle))
			return false;
		if (body == null) 
		{
			if (other.body != null)
				return false;
		}
		else if (!body.equals(other.body))
			return false;
		if (bullet != other.bullet)
			return false;
		if (centerFixture == null) 
		{
			if (other.centerFixture != null)
				return false;
		}
		else if (!centerFixture.equals(other.centerFixture))
			return false;
		
		if (centralPoint == null)
		{
			if (other.centralPoint != null)
				return false;
		}
		else if (!centralPoint.equals(other.centralPoint))
			return false;
		if (collidable != other.collidable)
			return false;
		if (Float.floatToIntBits(density) != Float.floatToIntBits(other.density))
			return false;
		if (fixedRotation != other.fixedRotation)
			return false;
		if (fixturesToAdd == null) 
		{
			if (other.fixturesToAdd != null)
				return false;
		}
		else if (!fixturesToAdd.equals(other.fixturesToAdd))
			return false;
		if (position == null) 
		{
			if (other.position != null)
				return false;
		}
		else if (!position.equals(other.position))
			return false;
		if (type != other.type)
			return false;
		return true;
	}

	@Override
	public String toString()
	{
		return "GameObject [body=" + Helper.toString(body) + ", world=" + Helper.toString(world) + ", centralPoint=" + centralPoint + ", density="
				+ density + ", centerFixture=" + centerFixture + ", type=" + type + ", position=" + position
				+ ", angle=" + angle + ", bullet=" + bullet + ", fixedRotation=" + fixedRotation + ", collidable="
				+ collidable + ", fixturesToAdd=" + fixturesToAdd + "]";
	}
}

=== Objects ===
package com.tdcrawl.tdc.objects;

import com.tdcrawl.tdc.objects.entities.Door;
import com.tdcrawl.tdc.objects.entities.living.Player;
import com.tdcrawl.tdc.objects.entities.living.types.categories.enemies.Slime;
import com.tdcrawl.tdc.objects.staticobjects.Ball;
import com.tdcrawl.tdc.objects.staticobjects.ItemObject;
import com.tdcrawl.tdc.objects.staticobjects.Platform;
import com.tdcrawl.tdc.objects.staticobjects.Rectangle;
import com.tdcrawl.tdc.registries.ObjectRegistry;

/**
 * A class for registering all the objects
 */
public class Objects
{
	/**
	 * Registers all the objects in the core game
	 */
	public static void registerAll()
	{
		ObjectRegistry.registerObject("rectangle", new Rectangle.CubeTemplate());
		ObjectRegistry.registerObject("platform", new Platform.PlatformTemplate());
		ObjectRegistry.registerObject("player", new Player.PlayerTemplate());
		ObjectRegistry.registerObject("ball", new Ball.BallTemplate());
		ObjectRegistry.registerObject("item", new ItemObject.ItemObjectTemplate());
		ObjectRegistry.registerObject("slime", new Slime.SlimeTemplate());
		ObjectRegistry.registerObject("door", new Door.DoorTemplate());
	}
}

=== Arm ===
package com.tdcrawl.tdc.objects.bodyparts;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;
import com.badlogic.gdx.physics.box2d.Shape;

public class Arm extends BodyPart
{
	/**
	 * For now the exact same as a {@link BodyPart}
	 * @param shape The shape the object will have
	 * @param position Where the object will be placed in the world
	 * @param type The BodyType of the object
	 * @param density How dense the object is
	 * @param restitution How bouncy the object is between 0 to 1.0f inclusive
	 * @param friction How much friction it has between 0 to 1.0f inclusive
	 * @param angle The angle of the body in radians
	 * @param bullet If the collision should be extra precise on this objects (used for really quick things)
	 * @param fixedRotation If rotation should be handled through physical interactions or just via programmatically setting it
	 * @param collidable If this has a solid collision box (true), or things will pass through it (false)
	 */
	public Arm(Shape shape, Vector2 position, BodyType type, float density, float restitution, 
			float friction, float angle, boolean bullet, boolean fixedRotation, boolean collidable)
	{
		super(shape, position, type, density, restitution, friction, angle, bullet, fixedRotation, collidable);
	}
}

=== BodyPart ===
package com.tdcrawl.tdc.objects.bodyparts;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;
import com.badlogic.gdx.physics.box2d.JointDef.JointType;
import com.badlogic.gdx.physics.box2d.Shape;
import com.badlogic.gdx.physics.box2d.joints.RevoluteJointDef;
import com.tdcrawl.tdc.joints.ObjectJoint;
import com.tdcrawl.tdc.objects.GameObject;
import com.tdcrawl.tdc.objects.fixtures.ObjectFixture;
import com.tdcrawl.tdc.util.Helper;

/**
 * A game object that is easily attachable to another object
 */
public abstract class BodyPart extends GameObject
{
	private ObjectJoint joint;
	
	/**
	 * A {@link GameObject} that is easily attachable to another object
	 * @param shape The shape the object will have
	 * @param position Where the object will be placed in the world
	 * @param type The BodyType of the object
	 * @param density How dense the object is
	 * @param restitution How bouncy the object is between 0 to 1.0f inclusive
	 * @param friction How much friction it has between 0 to 1.0f inclusive
	 * @param angle The angle of the body in radians
	 * @param bullet If the collision should be extra precise on this objects (used for really quick things)
	 * @param fixedRotation If rotation should be handled through physical interactions or just via programmatically setting it
	 * @param collidable If this has a solid collision box (true), or things will pass through it (false)
	 * @param centerPoint The position the center fixture will be placed out
	 */
	public BodyPart(Shape shape, Vector2 position, BodyType type, float density, float restitution, float friction,
			float angle, boolean bullet, boolean fixedRotation, boolean collidable, Vector2 centerPoint)
	{
		super(shape, position, type, density, restitution, friction, angle, bullet, fixedRotation, collidable, centerPoint);
	}
	
	/**
	 * A {@link GameObject} that is easily attachable to another object
	 * @param shape The shape the object will have
	 * @param position Where the object will be placed in the world
	 * @param type The BodyType of the object
	 * @param density How dense the object is
	 * @param restitution How bouncy the object is between 0 to 1.0f inclusive
	 * @param friction How much friction it has between 0 to 1.0f inclusive
	 * @param angle The angle of the body in radians
	 * @param bullet If the collision should be extra precise on this objects (used for really quick things)
	 * @param fixedRotation If rotation should be handled through physical interactions or just via programmatically setting it
	 * @param collidable If this has a solid collision box (true), or things will pass through it (false)
	 */
	public BodyPart(Shape shape, Vector2 position, BodyType type, float density, float restitution, float friction,
			float angle, boolean bullet, boolean fixedRotation, boolean collidable)
	{
		super(shape, position, type, density, restitution, friction, angle, bullet, fixedRotation, collidable);
	}
	
	/**
	 * A {@link GameObject} that is easily attachable to another object
	 * @param position Where the object will be placed in the world
	 * @param type The BodyType of the object
	 * @param angle The angle of the object (degrees I think)
	 * @param bullet If the collision should be extra precise on this objects (used for really quick things)
	 * @param fixedRotation If rotation should be handled through physical interactions or just via programmatically setting it
	 * @param collidable If this has a solid collision box (true), or things will pass through it (false)
	 * @param centerFixture The fixture that will be added to the body as the base fixture (if null no fixture will be added)
	 */
	public BodyPart(Vector2 position, BodyType type, float angle, boolean bullet, boolean fixedRotation,
			boolean collidable, ObjectFixture centerFixture)
	{
		super(position, type, angle, bullet, fixedRotation, collidable, centerFixture);
	}
	
	/**
	 * Attaches this object to the specified object
	 * @param go The object to attach to
	 * @param anchor The offset of the GameObject's origin to attach this to (Vector.Zero for no offset)
	 */
	public void attatch(GameObject go, Vector2 anchor)
	{
		if(go.initialized() && initialized())
		{
			RevoluteJointDef jointDef = new RevoluteJointDef();
			jointDef.bodyA = go.getBody(); 
			jointDef.bodyB = getBody();
			jointDef.localAnchorA.set(anchor);
			
			ObjectJoint joint = new ObjectJoint(jointDef);
			
			joint.attach();
		}
		else
			throw new IllegalStateException("Cannot add a part to an uninitialized object!");
	}
	
	/**
	 * Detaches the part from the attached object
	 */
	public void detatch()
	{
		if(attached())
		{
			Helper.removeJoint(getJoint());
			joint = null;
		}
	}
	
	public boolean attached() { return joint != null; }
	public ObjectJoint getJoint() { return joint; }
	public JointType getJointType() { return joint.getJointType(); }
}

=== Door ===
package com.tdcrawl.tdc.objects.entities;

import com.badlogic.gdx.graphics.Camera;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;
import com.badlogic.gdx.physics.box2d.CircleShape;
import com.badlogic.gdx.physics.box2d.PolygonShape;
import com.badlogic.gdx.physics.box2d.World;
import com.tdcrawl.tdc.objects.GameObject;
import com.tdcrawl.tdc.objects.fixtures.ObjectFixture;
import com.tdcrawl.tdc.registries.templates.ObjectData;
import com.tdcrawl.tdc.registries.templates.ObjectTemplate;
import com.tdcrawl.tdc.util.Helper;
import com.tdcrawl.tdc.util.Reference;

/**
 * @author Cornchip
 */
public class Door extends Entity
{
	private boolean opened = true;
	private boolean locked = false;
	
	private ObjectFixture top, bottom;
	
	private float amtOpen = 0;
	private float openAmount;
	
	private Vector2 dimensions;
	
	public Door(Vector2 position, Vector2 dimensions, float angle, float openAmount)
	{
		super(position, BodyType.KinematicBody, angle, false, true, true, setupCenterFixture());
		
		this.dimensions = dimensions;
		this.openAmount = openAmount;
	}
	
	@Override
	public void init(World world)
	{
		super.init(world);
		
		PolygonShape topDoorShape = new PolygonShape();
		
		topDoorShape.setAsBox(dimensions.x, dimensions.y / 2);
		top = new ObjectFixture(true, 1.0f, 0.1f, 0.6f, topDoorShape, new Vector2(0, dimensions.y / 2));
		
		PolygonShape bottomDoorShape = new PolygonShape();
		
		bottomDoorShape.setAsBox(dimensions.x, dimensions.y / 2);
		bottom = new ObjectFixture(true, 1.0f, 0.1f, 0.6f, bottomDoorShape, new Vector2(0, -dimensions.y / 2));
		
		Helper.addFixture(top, this);
		Helper.addFixture(bottom, this);
	}
	
	@Override
	public void tick(float delta, Camera cam)
	{      
		if(amtOpen < 1e-4f)
			amtOpen = 0;
		
		if(opened)
			open();
		else
			close();
	}
	
	private static ObjectFixture setupCenterFixture()
	{
		CircleShape center = new CircleShape();
		center.setRadius(0f);
		return new ObjectFixture(false, 0, 0, 0, center, new Vector2(0, 0));
	}
	
	public void setOpen(boolean open) { opened = open; }
	
	private void close()
	{
		if(!locked && amtOpen > 0)
		{
			amtOpen -= 0.1f;
			Helper.moveShape(top.getShape(), new Vector2(0, -0.1f));
			Helper.moveShape(bottom.getShape(), new Vector2(0, 0.1f));
			
			getBody().setAwake(true);
		}
	}

	private void open()
	{
		if(!locked && amtOpen < openAmount)
		{
			amtOpen += 0.1f;
			Helper.moveShape(top.getShape(), new Vector2(0, 0.1f));
			Helper.moveShape(bottom.getShape(), new Vector2(0, -0.1f));
			
			getBody().setAwake(true);
		}
	}
	
	public static class DoorTemplate implements ObjectTemplate
	{
		@Override
		public GameObject create(ObjectData data)
		{
			Reference.debugLog("" + data.getOrDef("angle", 0), this);
			Door d = new Door(data.position, data.dimensions, data.getOrDef("angle", 0), data.getOrDef("openAmount", 1f));
			d.setOpen(data.getOrDef("opened", false));
			return d;
		}
	}
	
	public boolean isLocked() { return locked; }
	public void setLocked(boolean locked) { this.locked = locked; }
}

=== Entity ===
package com.tdcrawl.tdc.objects.entities;

import com.badlogic.gdx.graphics.Camera;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;
import com.badlogic.gdx.physics.box2d.Shape;
import com.tdcrawl.tdc.levels.rooms.Room;
import com.tdcrawl.tdc.objects.GameObject;
import com.tdcrawl.tdc.objects.fixtures.ObjectFixture;

/**
 * The same thing as a GameObject, but has a tick function called every game update
 */
public abstract class Entity extends GameObject
{
	/**
	 * The room the entity is currently in
	 */
	private Room room;
	
	/**
	 * Creates an Entity with all the information needed to initialize it when ready
	 * @param shape The shape the object will have
	 * @param position Where the object will be placed in the world
	 * @param type The BodyType of the object
	 * @param density How dense the object is
	 * @param restitution How bouncy the object is between 0 to 1.0f inclusive
	 * @param friction How much friction it has between 0 to 1.0f inclusive
	 * @param angle The angle of the body in radians
	 * @param bullet If the collision should be extra precise on this objects (used for really quick things)
	 * @param fixedRotation If rotation should be handled through physical interactions or just via programmatically setting it
	 * @param collidable If this has a solid collision box (true), or things will pass through it (false)
	 * @param centerPoint The fixture that will be added to the body as the base fixture (if null no fixture will be added)
	 */
	public Entity(Shape shape, Vector2 position, BodyType type, float density, float restitution, float friction,
			float angle, boolean bullet, boolean fixedRotation, boolean collidable, Vector2 centerPoint)
	{
		super(shape, position, type, density, restitution, friction, angle, bullet, fixedRotation, collidable, centerPoint);
	}
	
	/**
	 * Creates an Entity with all the information needed to initialize it when ready
	 * @param shape The shape the object will have
	 * @param shape The shape the object will have
	 * @param position Where the object will be placed in the world
	 * @param type The BodyType of the object
	 * @param density How dense the object is
	 * @param restitution How bouncy the object is between 0 to 1.0f inclusive
	 * @param friction How much friction it has between 0 to 1.0f inclusive
	 * @param angle The angle of the body in radians
	 * @param bullet If the collision should be extra precise on this objects (used for really quick things)
	 * @param fixedRotation If rotation should be handled through physical interactions or just via programmatically setting it
	 * @param collidable If this has a solid collision box (true), or things will pass through it (false)
	 */
	public Entity(Shape shape, Vector2 position, BodyType type, float density, float restitution, float friction,
			float angle, boolean bullet, boolean fixedRotation, boolean collidable)
	{
		super(shape, position, type, density, restitution, friction, angle, bullet, fixedRotation, collidable);
	}
	
	/**
	 * Creates an Entity with all the information needed to initialize it when ready
	 * @param position Where the object will be placed in the world
	 * @param type The BodyType of the object
	 * @param angle The angle of the object (degrees I think)
	 * @param bullet If the collision should be extra precise on this objects (used for really quick things)
	 * @param fixedRotation If rotation should be handled through physical interactions or just via programmatically setting it
	 * @param collidable If this has a solid collision box (true), or things will pass through it (false)
	 * @param centerFixture The fixture that will be added to the body as the base fixture (if null no fixture will be added)
	 */
	public Entity(Vector2 position, BodyType type, float angle, boolean bullet, boolean fixedRotation,
			boolean collidable, ObjectFixture centerFixture)
	{
		super(position, type, angle, bullet, fixedRotation, collidable, centerFixture);
	}
	
	/**
	 * Called once every game tick
	 * @param delta Time since this was last called
	 * @param cam The camera used to render the game
	 */
	public abstract void tick(float delta, Camera cam);
	
	// Getters & Setters //
	
	public void setRoom(Room room) { this.room = room; }
	public Room getRoom() { return room; }
}

=== LivingEntity ===
package com.tdcrawl.tdc.objects.entities.living;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;
import com.badlogic.gdx.physics.box2d.Shape;
import com.tdcrawl.tdc.items.inventory.Inventory;
import com.tdcrawl.tdc.objects.entities.Entity;
import com.tdcrawl.tdc.objects.entities.living.types.EntityType;
import com.tdcrawl.tdc.objects.fixtures.ObjectFixture;

/**
 * An Entity, but with health and items!
 * @see Entity
 * @author Cornchip
 */
public abstract class LivingEntity extends Entity
{
	private int health, maxHealth;
	
	private Inventory inventory;
	
	/**
	 * @see Entity#Entity(Shape, Vector2, BodyType, float, float, float, float, boolean, boolean, boolean)
	 * @param maxHealth The maximum health the LivingEntity can have
	 */
	public LivingEntity(Shape shape, Vector2 position, BodyType type, float density, float restitution, float friction,
			float angle, boolean bullet, boolean fixedRotation, boolean collidable, Vector2 centerPoint, int maxHealth)
	{
		super(shape, position, type, density, restitution, friction, angle, bullet, fixedRotation, collidable, centerPoint);
		
		this.maxHealth = maxHealth;
		this.health = maxHealth;
	}
	
	/**
	 * @see Entity#Entity(Shape, Vector2, BodyType, float, float, float, float, boolean, boolean, boolean, Vector2)
	 * @param maxHealth The maximum health the LivingEntity can have
	 */
	public LivingEntity(Shape shape, Vector2 position, BodyType type, float density, float restitution, float friction,
			float angle, boolean bullet, boolean fixedRotation, boolean collidable, int maxHealth)
	{
		super(shape, position, type, density, restitution, friction, angle, bullet, fixedRotation, collidable);
		
		this.maxHealth = maxHealth;
		this.health = maxHealth;
	}
	
	/**
	 * @see Entity#Entity(Vector2, BodyType, float, boolean, boolean, boolean, ObjectFixture)
	 * @param maxHealth The maximum health the LivingEntity can have
	 */
	public LivingEntity(Vector2 position, BodyType type, float angle, boolean bullet, boolean fixedRotation,
			boolean collidable, ObjectFixture centerFixture, int maxHealth)
	{
		super(position, type, angle, bullet, fixedRotation, collidable, centerFixture);
		
		this.maxHealth = maxHealth;
		this.health = maxHealth;
	}
	
	/**
	 * Called whenever a LivingEntity should die
	 * If this returns false, the living entity will not die
	 * @return false if it should not die, true if it should
	 */
	public abstract boolean die();
	
	// Getters & Setters //
	
	public abstract EntityType getEntityType();
	
	public void takeDamage(int amt) { health -= amt; if(health <= 0) die(); }
	public void heal(int amt) { health += amt; }
	
	public abstract boolean invulnerable();
	
	public int getMaxHealth() { return maxHealth; }
	public void setMaxHealth(int h) { this.maxHealth = h; }
	public int getHealth() { return health; }
	public void setHealth(int amt) { this.health = amt; }

	public Inventory getInventory() { return inventory; }
	public void setInventory(Inventory inventory) { this.inventory = inventory; }
	
	@Override
	public String toString()
	{
		return "LivingEntity [health=" + health + "/" + maxHealth + "; " + super.toString() + "]";
	}
}

=== Player ===
package com.tdcrawl.tdc.objects.entities.living;

import java.util.ArrayList;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.Camera;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;
import com.badlogic.gdx.physics.box2d.CircleShape;
import com.badlogic.gdx.physics.box2d.Fixture;
import com.badlogic.gdx.physics.box2d.PolygonShape;
import com.badlogic.gdx.physics.box2d.World;
import com.tdcrawl.tdc.items.Item;
import com.tdcrawl.tdc.items.inventory.PlayerInventory;
import com.tdcrawl.tdc.items.items.weapons.Weapon;
import com.tdcrawl.tdc.items.items.weapons.melee.MeleeWeapon;
import com.tdcrawl.tdc.items.items.weapons.melee.Sword;
import com.tdcrawl.tdc.objects.GameObject;
import com.tdcrawl.tdc.objects.bodyparts.Arm;
import com.tdcrawl.tdc.objects.entities.living.types.EntityType;
import com.tdcrawl.tdc.objects.fixtures.ObjectFixture;
import com.tdcrawl.tdc.objects.fixtures.Sensor;
import com.tdcrawl.tdc.registries.templates.ObjectData;
import com.tdcrawl.tdc.registries.templates.ObjectTemplate;
import com.tdcrawl.tdc.util.Helper;
import com.tdcrawl.tdc.util.Reference;
import com.tdcrawl.tdc.util.UserDataParser;

public class Player extends LivingEntity
{
	private final float ACCELERATION = 10.0f; // x m/s^2
	private final float JUMP_STRENGTH = 10.5f; // acceleration applied when jump occurs
	private final int JUMPS_ALLOWED_IN_AIR = 1;
	private final float TIME_BETWEEN_JUMPS = 0.4f;
	
	private Vector2 startPos;
	
	private int inAirJumps = 0;
	private float timeSinceLastJump = 0;
	
	private static final float height = 0.45f;
	private static final float headRadius = 0.2f;
	private static final float width = 0.2f;
	
	private Arm arm;
	private boolean facingLeft = false;
	
	private static final Vector2 ARM_OFFSET = new Vector2(0f, height - 0.2f);
	
	private int numFootContacts = 0;
	
	private PlayerInventory inventory;
	private Item heldItem;
	private Sensor itemSensor;
	
	private float timeSinceSwing = 0.0f;
	private static final float SWING_STRENGTH = 0.25f;
	private static final float TIME_BETWEEN_SWINGS = 0.3f;
	private ArrayList<LivingEntity> alreadyHit = new ArrayList<LivingEntity>();
	
	private ShapeRenderer sr = new ShapeRenderer();
	
	private boolean flying = false, noclip = false; // I did this to test stuff dan, dont worry about it (press f or c to activate them respectively)
	
	public Player(Vector2 position, int maxHealth)
	{
		super(position, BodyType.DynamicBody, 0, true, true, true, createCenterFixture(), maxHealth);
		
		CircleShape headShape = new CircleShape();
		headShape.setRadius(headRadius);
		ObjectFixture head = new ObjectFixture(true, 1.5f, 0.1f, 0.05f, headShape, new Vector2(0, height + headRadius));
		
		this.addFixture(head);
		
		inventory = new PlayerInventory(new Sword(), null, null);
	}
	
	@Override
	public void init(World world)
	{
		super.init(world);
		
		PolygonShape armShape = new PolygonShape();
		armShape.setAsBox(0.3f, 0.08f, new Vector2(0.25f, 0), 0.0f); // MAKE THE 0.25f NEGATIVE WHEN LEFT
		arm = new Arm(armShape, getPosition(), BodyType.DynamicBody, getDensity(), 0, 0, 0, false, true, false);
		
		arm.init(world);
		arm.attatch(this, ARM_OFFSET);
		
		PolygonShape shape = new PolygonShape();
		shape.setAsBox(width - 0.05f, 0.05f);
		
		Sensor footSensor = new Sensor(shape, new Vector2(0,  -height))
		{
			@Override
			public void onCollide(GameObject other, ObjectFixture fixture)
			{
				numFootContacts++;
			}
			
			@Override
			public void onUncollide(GameObject other, ObjectFixture fixture)
			{
				numFootContacts--;
			}
		};
		
		footSensor.init(getBody());

		startPos = Helper.clone(getPosition());
		
		switchItem(inventory.getItems()[0], true, false);
	}
	
	/**
	 * Just for use in the constructor to make the center fixture
	 * @return The center fixture
	 */
	private static ObjectFixture createCenterFixture()
	{
		PolygonShape shape = new PolygonShape();
		shape.setAsBox(width, height);
		
		ObjectFixture centerFixture = new ObjectFixture(true, 6.0f, 0.0f, 0.2f, shape, new Vector2(0, 0));
		return centerFixture;
	}
	
	@Override
	public void tick(float delta, Camera cam)
	{
		timeSinceLastJump += delta;
		timeSinceSwing += delta;
		
		if(Gdx.input.isButtonPressed(Input.Buttons.LEFT) && timeSinceSwing > TIME_BETWEEN_SWINGS)
		{
			timeSinceSwing = 0.0f;
		}
		
		if(facingLeft)
		{
			if(timeSinceSwing < TIME_BETWEEN_SWINGS / 5)
			{
				arm.setAngle(arm.getAngle() - SWING_STRENGTH);
			}
			else if(timeSinceSwing <= TIME_BETWEEN_SWINGS * 9 / 10)
			{
				arm.setAngle(arm.getAngle() + SWING_STRENGTH);
			}
		}
		else
		{
			if(timeSinceSwing < TIME_BETWEEN_SWINGS / 5)
			{
				arm.setAngle(arm.getAngle() + SWING_STRENGTH);
			}
			else if(timeSinceSwing <= TIME_BETWEEN_SWINGS * 9 / 10)
			{
				arm.setAngle(arm.getAngle() - SWING_STRENGTH);
			}
		}
		
		int mX = Gdx.input.getX();
		int mY = Gdx.input.getY();
		
		Vector2 mouseCoordsInMeters = new Vector2(mX, mY);
		mouseCoordsInMeters = Helper.screenCoordinatesToMeters(mouseCoordsInMeters, cam);
		
		if(mX >= 0 && mX < Gdx.graphics.getWidth() && mY >= 0 && mY < Gdx.graphics.getHeight())
		{
			if(timeSinceSwing > TIME_BETWEEN_SWINGS * 9 / 10)
			{
				arm.setAngle(Helper.angleTo(getPosition().cpy().add(ARM_OFFSET).add(ARM_OFFSET), mouseCoordsInMeters, ARM_OFFSET));
			}
		}
		
		// Draws a fancy line to ur cursor based off where ur arm starts
		if(Reference.isDebug() && cam != null)
		{
	        sr.setColor(Color.RED);
	        sr.setProjectionMatrix(cam.combined);
	
	        sr.begin(ShapeType.Line);
	        sr.line(getPosition().x + ARM_OFFSET.x, getPosition().y + ARM_OFFSET.y,
	        		mouseCoordsInMeters.x, mouseCoordsInMeters.y);
	        
	        sr.end();
		}
		
		// Resets you to where the player started
		if(Reference.isDebug())
		{
			if(Gdx.input.isKeyPressed(Input.Keys.R))
			{
				setPosition(startPos);
				getBody().setLinearVelocity(0, 0);
			}
			
			if(Gdx.input.isKeyJustPressed(Input.Keys.F))
			{
				flying = !flying;
			}
			
			if(Gdx.input.isKeyJustPressed(Input.Keys.C)) // WARNING: Once this is turned on then off again, sensors and anything else that was set to no collide WILL become collidable.
				// And I really dont feel the need to create a list of noncollidable fixtures and check them when undoing the noclip.
			{
				noclip = !noclip;
				
				for(Fixture f : getBody().getFixtureList())
				{
				    if(!(UserDataParser.getObjectFixture(f) instanceof Sensor))
				    {
				        f.setSensor(noclip);
				    }
				}
			}
		}
		
		Vector2 acceleration = new Vector2();
		
		acceleration.x = Helper.toInt(Gdx.input.isKeyPressed(Input.Keys.D) || Gdx.input.isKeyPressed(Input.Keys.RIGHT));
		acceleration.x -= Helper.toInt(Gdx.input.isKeyPressed(Input.Keys.A) || Gdx.input.isKeyPressed(Input.Keys.LEFT));
		
		acceleration.x *= ACCELERATION * delta;
		
		if(this.isOnGround())
			inAirJumps = 0;
		
		if(Gdx.input.isKeyPressed(Input.Keys.SPACE) || Gdx.input.isKeyPressed(Input.Keys.W))
		{			
			if(timeSinceLastJump >= TIME_BETWEEN_JUMPS)
			{
				if(flying || inAirJumps < JUMPS_ALLOWED_IN_AIR || this.isOnGround())
				{
					if(!this.isOnGround())
					{
						inAirJumps++;
					}
					
					timeSinceLastJump = 0;
					acceleration.y += JUMP_STRENGTH;
				}
			}
		}
		
		if(Gdx.input.isKeyPressed(Input.Keys.NUM_1))
		{
			switchItem(inventory.getItems()[0], false, facingLeft);
		}
		
		if(Gdx.input.isKeyPressed(Input.Keys.NUM_2))
		{
			switchItem(inventory.getItems()[1], false, facingLeft);
		}
		
		if(Gdx.input.isKeyPressed(Input.Keys.NUM_3))
		{
			switchItem(inventory.getItems()[2], false, facingLeft);
		}
		
		if(Math.abs(arm.getAngle()) > Math.PI / 2 && Math.abs(arm.getAngle()) < Math.PI * 3 / 2 && !facingLeft && timeSinceSwing > TIME_BETWEEN_SWINGS * 9 / 10)
		{
			switchItem(heldItem, false, true);
		}
		
		if((Math.abs(arm.getAngle()) < Math.PI / 2 || Math.abs(arm.getAngle()) > Math.PI * 3 / 2) && facingLeft && timeSinceSwing > TIME_BETWEEN_SWINGS * 9 / 10)
		{
			switchItem(heldItem, false, false);
		}
			
		getBody().setLinearVelocity(getBody().getLinearVelocity().add(acceleration));
	}
	
	private void switchItem(Item newItem, boolean initial, boolean left)
	{
		heldItem = newItem;
		float yoffset = 0.0f;
		float xoffset = 0.0f;
		
		if(!initial)
		{	
			Helper.removeFixture(itemSensor);
		}
		
		PolygonShape item = new PolygonShape();
		if(heldItem == null)
		{
			item.setAsBox(0.1f, -0.1f);
			xoffset = 0.05f;
			yoffset = -0.05f;
		}
		else
		{
			item.setAsBox(heldItem.getDimensions().x, heldItem.getDimensions().y);
			xoffset = heldItem.getDimensions().x / 2;
			yoffset = heldItem.getDimensions().y / 2;
			facingLeft = false;
			
			if(left)
			{
				yoffset = -2 * yoffset;
				facingLeft = true;
			}
		}
		
		itemSensor = new Sensor(item, new Vector2(0.5f + xoffset, 0.2f + yoffset))
		{
			
			@Override
			public void onCollide(GameObject other, ObjectFixture fixture)
			{
				if(other instanceof LivingEntity && timeSinceSwing < TIME_BETWEEN_SWINGS * 9 / 10 && !alreadyHit.contains(other))
				{
					System.out.print("Hit for ");
					if(heldItem instanceof MeleeWeapon)
					{
						((LivingEntity) other).takeDamage(((MeleeWeapon) heldItem).getDamage());
						System.out.print(((Weapon) heldItem).getDamage());
					}
					else
					{
						((LivingEntity) other).takeDamage(1);
						System.out.print("1");
					}
					System.out.println(" damage.");
					alreadyHit.add((LivingEntity) other);
				}

			}
			
			@Override
			public void onUncollide(GameObject other, ObjectFixture fixture)
			{
				alreadyHit.clear();
			}
		};
		
		
		Helper.addFixture(itemSensor, arm);
	}

	@Override
	public boolean die()
	{
		return false;
	}

	@Override
	public boolean invulnerable()
	{
		return false;
	}
	
	public static class PlayerTemplate implements ObjectTemplate
	{
		@Override
		public GameObject create(ObjectData data)
		{
			return new Player(data.position, 20);
		}
	}
	
	@Override
	public boolean isOnGround()
	{
		return numFootContacts >= 1;
	}
	
	@Override
	public EntityType getEntityType() { return EntityType.PLAYER; }
}

=== EntityType ===
package com.tdcrawl.tdc.objects.entities.living.types;

public enum EntityType
{
	HOSTILE,
	NEUTRAL,
	FRIENDLY,
	PLAYER
}

=== IPathable ===
package com.tdcrawl.tdc.objects.entities.living.types;

import com.tdcrawl.tdc.objects.entities.living.Player;

public interface IPathable 
{
	//going to be used to move the entity in the proper direction / get the new coordinates
	public float[] getPath(Player play);
}

=== HostileEntity ===
package com.tdcrawl.tdc.objects.entities.living.types.categories;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;
import com.badlogic.gdx.physics.box2d.Shape;
import com.tdcrawl.tdc.objects.entities.living.LivingEntity;
import com.tdcrawl.tdc.objects.entities.living.Player;
import com.tdcrawl.tdc.objects.entities.living.types.EntityType;
import com.tdcrawl.tdc.objects.entities.living.types.IPathable;

public abstract class HostileEntity extends LivingEntity implements IPathable
{

	public HostileEntity(Shape shape, Vector2 position, BodyType type, float density, float restitution, float friction,
			float angle, boolean bullet, boolean fixedRotation, boolean collidable, int maxHealth) {
		super(shape, position, type, density, restitution, friction, angle, bullet, fixedRotation, collidable, maxHealth);
		
		
	}
	/**
	 * Created to path to the player and attack them.
	 * Will return distance to player and angle to them, using x & y to see if negative
	 */
	public float[] getPath(Player play)
	{
		/*
		 * Goes like This:
		 * 0: X Difference
		 * 1: Y Difference
		 * 2: Angle (Degrees) [Absolute Angle]
		 * 
		 */
		float[] dataPack = new float[3];
		
		Vector2 playerCoord = new Vector2();
		playerCoord.set(play.getPosition());
		
		Vector2 curretCoord = new Vector2();
		curretCoord.set(this.getPosition());
		
		dataPack[0] = (float) playerCoord.x - curretCoord.x;
		dataPack[1] = (float) playerCoord.y - curretCoord.y;
		dataPack[2] = (float) Math.atan(Math.abs(dataPack[1]/dataPack[0]));
		dataPack[2] *= 180/Math.PI;
		
		if(dataPack[0] >= 0)
		{
			if(dataPack[1] <= 0)
				dataPack[2] = 360 - dataPack[2];
		}
		if(dataPack[0] <= 0)
		{
			if(dataPack[1] <= 0)
				dataPack[2] = 270 - dataPack[2];
			else
				dataPack[2] = 180 - dataPack[2];
		}
		
		
		/*
		for(int ye = 0; ye < dataPack.length; ye++)
			System.out.println("Data: " + dataPack[ye]);
		*/
		
		return dataPack;
	}
	
	@Override
	public EntityType getEntityType() { return EntityType.HOSTILE; }
}

=== Ghost ===
package com.tdcrawl.tdc.objects.entities.living.types.categories.enemies;

public class Ghost 
{
	
}

=== Slime ===
package com.tdcrawl.tdc.objects.entities.living.types.categories.enemies;

import com.badlogic.gdx.graphics.Camera;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;
import com.badlogic.gdx.physics.box2d.CircleShape;
import com.badlogic.gdx.physics.box2d.Shape;
import com.tdcrawl.tdc.objects.GameObject;
import com.tdcrawl.tdc.objects.entities.Entity;
import com.tdcrawl.tdc.objects.entities.living.Player;
import com.tdcrawl.tdc.objects.entities.living.types.categories.HostileEntity;
import com.tdcrawl.tdc.registries.templates.ObjectData;
import com.tdcrawl.tdc.registries.templates.ObjectTemplate;
import com.tdcrawl.tdc.util.Helper;

//whatever else corns needs, I'll get. I need to create the object and do testing.
public class Slime extends HostileEntity
{
	float lastJump = 0;
	float timeCounter = 0;
	
	public Slime(Shape shape, Vector2 position, float friction,
			float angle, boolean bullet, boolean fixedRotation, boolean collidable, int maxHealth)
	{
		super(shape, position, BodyType.DynamicBody, 5f, 0f, friction, angle, bullet, fixedRotation, collidable, maxHealth);
	}
	
	@Override
	public boolean die()
	{
		return true;
	}

	@Override
	public boolean invulnerable()
	{
		return false;
	}
	
	
	public void takeDamage(int amt) 
	{ super.takeDamage(amt); jump();}

	//Hops really high some times for no apparent reason.
	//Sometimes short after going off the player.
	public void jump()
	{
		Player currentPlayer = null;
		
		for(Entity o : getRoom().getEntitiesInRoom())
		{
			if(o instanceof Player)
			{
				 currentPlayer = (Player)o;
				// System.out.println("Player Found!");
			}
		}
		
		if(currentPlayer == null)
		{
			getBody().applyForceToCenter(getBody().getMass() * 90.0f, 0, true);
		}
		else
		{
				float[] dataChunk = super.getPath(currentPlayer);
				Vector2 hopDir = new Vector2();
				
				hopDir.y = Helper.randomizer(getBody().getMass() * 300.0f, getBody().getMass() * 200);
				//might work on more advanced hops; higher pathing in later tests
				if(dataChunk[2] > 90 && dataChunk[2] < 270)
				{
					hopDir.x = Helper.randomizer(getBody().getMass() * -50, getBody().getMass() * -25);
				}
				else
				{
					hopDir.x = Helper.randomizer(getBody().getMass() * 50, getBody().getMass() * 25);
				}
				
				System.out.println("Force is: " + getBody().getLinearVelocity());
				getBody().applyForceToCenter(hopDir, true);
		}
	}
	
	public static class SlimeTemplate implements ObjectTemplate
	{
		@Override
		public GameObject create(ObjectData data)
		{
			CircleShape shape = new CircleShape();
			if(data.radius == 0)
				data.radius = Helper.randomizer(0.25f, 0.5f);
			shape.setRadius(data.radius);
			
//(Shape shape, Vector2 position, float friction, float angle, boolean bullet, boolean fixedRotation, boolean collidable, int maxHealth)
			return new Slime(shape, data.position, data.getOrDef("friction", 0.2f), data.getOrDef("angle", 0f), true, true, true, (int)data.getOrDef("maxHealth", 20f));
		}
		
		/*
		 * Get or Def Exemplary:
		 * data.getOrDef("restitution", 0.1f)
		 * returns the 'restitution' based on string key, else gives value of 0.1f
		 */
		
	}

	@Override
	public void tick(float delta, Camera cam) 
	{
		//used to counteract gravity, makes it 'bouncier'
		getBody().applyForceToCenter(new Vector2(0, getBody().getMass() * 2.0f), true);
		
		if(getLastJump()+3 <= timeCounter || this.isOnGround())
		{
			jump();
			setLastJump(timeCounter);
		}
		
		timeCounter += delta;
	}
	public float getLastJump() {return this.lastJump;}
	public void setLastJump(float currentTime) {this.lastJump = currentTime;}
}

=== ObjectFixture ===
package com.tdcrawl.tdc.objects.fixtures;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.Fixture;
import com.badlogic.gdx.physics.box2d.FixtureDef;
import com.badlogic.gdx.physics.box2d.Shape;
import com.tdcrawl.tdc.util.Helper;

/**
 * A nicer way of creating a fixture and adding it to a body
 */
public class ObjectFixture
{	
	private Fixture fixture;
	private Body body;
	
	// Once the object is initialized, this values are not updated. Use the getters and setters instead
	private boolean collidable;
	private float density, restitution, friction;
	private Shape shape;
	private Vector2 position;
	
	/**
	 * A nicer way of creating a fixture and adding it to a body
	 * @param collidable If the fixture will stop things from passing through (overridden by body if body is noncollidable)
	 * @param density How dense this is
	 * @param restitution How bouncy this is
	 * @param friction How much friction this has
	 * @param shape The shape of this
	 * @param position The relative position of it to the body (e.g. 0, 0 would be directly at the center of the body)
	 */
	public ObjectFixture(boolean collidable, float density, float restitution, float friction, Shape shape, Vector2 position)
	{
		this.collidable = collidable;
		this.density = density;
		this.restitution = restitution;
		this.friction = friction;
		this.shape = shape;
		this.position = position;
	}
	
	/**
	 * Adds the fixture to the body
	 * @param b The body to append the fixture to
	 */
	public void init(Body b)
	{
		if(initialized())
			throw new IllegalStateException("This ObjectFixture has already been initialized!");
		
		this.body = b;
		
		FixtureDef fixtureDef = new FixtureDef();
		fixtureDef.density = getDensity();
		fixtureDef.friction = getFriction();
				
		Helper.moveShape(getShape(), position);
		
		fixtureDef.shape = getShape();
		fixtureDef.restitution = getRestitution();
		fixtureDef.isSensor = !isCollidable() || !isCollidable();
		
		fixture = b.createFixture(fixtureDef);
		
		// This allows me to see what ObjectFixture this fixture belongs to later
		fixture.setUserData(this);
		
		shape.dispose(); // We no longer need this
		shape = null; // Prevents assertions failing later on when someone tries to reference the shape after it was disposed
	}
	
	public void remove()
	{
		if(initialized())
		{
			if(getBody() != null)
			{
				int i = body.getFixtureList().indexOf(getFixture(), false);
				if(i != -1)
					body.getFixtureList().removeIndex(i);
			}
		}
		else
			throw new IllegalStateException("Cannot remove an uninitialized fixture!");
	}
	
	/**
	 * Checks if the fixture has been added to a body
	 * @return true if it has been attached, false it not
	 */
	public boolean initialized()
	{
		return fixture != null;
	}
	
	// Getters & setters //
	
	public float getDensity()
	{
		return density;
	}
	
	public void setDensity(float density)
	{
		if(initialized())
			throw new IllegalStateException("Cannot set the density of an already-initialized object!");
		else
			this.density = density;
	}
	
	public float getRestitution()
	{
		if(initialized())
			return fixture.getRestitution();
		else
			return restitution;
	}
	
	public void setRestitution(float rest)
	{
		if(initialized())
			fixture.setRestitution(rest);
		else
			this.restitution = rest;
	}
	
	public float getFriction()
	{
		if(initialized())
			return fixture.getFriction();
		else
			return friction;
	}
	
	public void setFriction(float friction)
	{
		if(initialized())
			fixture.setFriction(friction);
		else
			this.friction = friction;
	}
	
	public Shape getShape()
	{
		if(initialized())
			return fixture.getShape();
		else
			return shape;
	}
	
	public void setShape(Shape shape)
	{
		if(initialized())
			throw new IllegalStateException("State cannot be set after initialization");
		else
			this.shape = shape;
	}

	public boolean isCollidable()
	{
		if(initialized())
			return !fixture.isSensor();
		else
			return collidable;
	}
	
	public void setCollidable(boolean collidable)
	{
		if(initialized())
			fixture.setSensor(!collidable);
		else
			this.collidable = collidable;
	}

	public Fixture getFixture() { return fixture; }
	
	public Body getBody() { return body; }

	@Override
	public String toString()
	{
		return "ObjectFixture [fixture=" + Helper.toString(fixture) + ", body=" + Helper.toString(body) + ", collidable=" + collidable + ", density="
				+ density + ", restitution=" + restitution + ", friction=" + friction + ", shape=" + Helper.toString(shape)
				+ ", position=" + position + "]";
	}
}

=== Sensor ===
package com.tdcrawl.tdc.objects.fixtures;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Shape;
import com.tdcrawl.tdc.events.Event;
import com.tdcrawl.tdc.events.EventCallback;
import com.tdcrawl.tdc.events.EventsHandler;
import com.tdcrawl.tdc.events.types.CollisionEvent;
import com.tdcrawl.tdc.events.types.CollisionEvent.CollisionState;
import com.tdcrawl.tdc.objects.GameObject;

public abstract class Sensor extends ObjectFixture
{
	static
	{
		EventsHandler.subscribe("onCollide", new EventCallback()
		{
			@Override
			public void callback(Event e)
			{
				CollisionEvent event = (CollisionEvent)e;
				
				// Checks if either of the events were sensors, and if so fire those events
				Object data = event.getFixture2() != null ? event.getFixture2().getFixture().getUserData() : null;
				
				if(!(data instanceof Sensor))
				{
					data = event.getFixture1() != null ? event.getFixture1().getFixture().getUserData() : null;

					if(!(data instanceof Sensor))
					{
						return; // Neither is a sensor, so just stop
					}
				}
				
				if(event.getState() == CollisionState.BEGIN_COLLISION)
					((Sensor)data).onCollide(event.getObject2(), event.getFixture2());
				else if(event.getState() == CollisionState.END_COLLISION)
					((Sensor)data).onUncollide(event.getObject2(), event.getFixture2());
			}
		});
	}
	
	public Sensor(Shape shape, Vector2 position)
	{
		super(false, 0, 0, 0, shape, position);
	}
	
	public abstract void onCollide(GameObject other, ObjectFixture fixture);
	public abstract void onUncollide(GameObject other, ObjectFixture fixture);

	@Override
	public String toString()
	{
		return "Sensor [" + super.toString() + "]";
	}
}

=== Ball ===
package com.tdcrawl.tdc.objects.staticobjects;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;
import com.badlogic.gdx.physics.box2d.CircleShape;
import com.tdcrawl.tdc.events.Event;
import com.tdcrawl.tdc.events.EventCallback;
import com.tdcrawl.tdc.events.EventsHandler;
import com.tdcrawl.tdc.events.types.CollisionEvent;
import com.tdcrawl.tdc.events.types.CollisionEvent.CollisionState;
import com.tdcrawl.tdc.objects.GameObject;
import com.tdcrawl.tdc.objects.entities.living.Player;
import com.tdcrawl.tdc.objects.fixtures.ObjectFixture;
import com.tdcrawl.tdc.registries.templates.ObjectData;
import com.tdcrawl.tdc.registries.templates.ObjectTemplate;

public class Ball extends GameObject
{
	public Ball(Vector2 position, float angle, boolean bullet, boolean fixedRotation, boolean collidable, ObjectFixture centerFixture)
	{
		super(position, BodyType.DynamicBody, angle, bullet, fixedRotation, collidable, centerFixture);
		
		EventsHandler.subscribe("onCollide", new EventCallback()
		{	
			@Override
			public void callback(Event e)
			{
				CollisionEvent event = (CollisionEvent)e;
				
				if(event.getState() == CollisionState.BEGIN_COLLISION)
				{
					if(event.getObject1() instanceof Player)
					{
						getBody().applyForceToCenter(new Vector2(0, 19.6f), true);
					}
				}
			}
		});
	}
	
	public static class BallTemplate implements ObjectTemplate
	{
		@Override
		public GameObject create(ObjectData data)
		{
			CircleShape shape = new CircleShape();
			shape.setRadius(data.radius);
			
			ObjectFixture fixture = new ObjectFixture(true, 1, data.getOrDef("restitution", 0.1f), 0.1f, shape, new Vector2(0, 0));
			
			return new Ball(data.position, 0, false, false, true, fixture);
		}
		
	}
}

=== ItemObject ===
package com.tdcrawl.tdc.objects.staticobjects;

import java.util.Map;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;
import com.badlogic.gdx.physics.box2d.PolygonShape;
import com.badlogic.gdx.physics.box2d.Shape;
import com.badlogic.gdx.physics.box2d.World;
import com.tdcrawl.tdc.items.Item;
import com.tdcrawl.tdc.objects.GameObject;
import com.tdcrawl.tdc.objects.fixtures.ObjectFixture;
import com.tdcrawl.tdc.registries.ItemRegistry;
import com.tdcrawl.tdc.registries.templates.ItemData;
import com.tdcrawl.tdc.registries.templates.ItemTemplate;
import com.tdcrawl.tdc.registries.templates.ObjectData;
import com.tdcrawl.tdc.registries.templates.ObjectTemplate;

public class ItemObject extends GameObject
{
	// This is not used once the object has been initialized
	private Vector2 velocity = Vector2.Zero;
	
	/**
	 * Stores the item that this object will hold
	 */
	private Item item;
	
	/**
	 * This constructor may change in the future, so it is kept private to avoid it's use other than in the {@link ItemObject#asObject(Item)} method.
	 * @param i The item to create the item with
	 */
	private ItemObject(Item i)
	{
		super(null, BodyType.DynamicBody, 0, false, false, true, new ObjectFixture(true, 0.7f, 0.0f, 0.0f, createShape(), Vector2.Zero));
		this.item = i;
	}
	
	/**
	 * Creates a new ItemObject that hasn't been initialized to the world yet that stores an item
	 * @param i The item to create it with
	 * @return The newly constructed ItemObject
	 */
	public static ItemObject asObject(Item i)
	{
		return new ItemObject(i);
	}
	
	/**
	 * <p><b>DO NOT CALL UNLESS POSITION HAS BEEN SET!</b></p>
	 * <p>Instead, call {@link ItemObject#init(World, Vector2, Vector2)}</p>
	 */
	@Override
	public void init(World world)
	{
		if(getPosition() == null)
			throw new IllegalStateException("GameObject#init(World) cannot be called on an ItemObject without position being set. The method ItemObject#init(World, Vector2, Vector2) must be used!");
		else
			init(world, getPosition(), getVelocity());
	}
	
	/**
	 * <p><b>CALL THIS INSTEAD OF </b>{@link GameObject#init(World)}</p>
	 * Initializes the object like normal, but with special information the item needs.
	 * @param world The world the item is in
	 * @param position Where to place the item
	 * @param velocity How fast to start the item moving. If no velocity is wanted, use {@code Vector2.Zero} or {@code null}
	 */
	public void init(World world, Vector2 position, Vector2 velocity)
	{
		setPosition(position);
		
		super.init(world);
		
		// "F = ma" used to calculate how much force to apply
		if(velocity != null)
			getBody().applyForceToCenter(velocity.x * getBody().getMass(), velocity.y * getBody().getMass(), true);
	}
	
	/**
	 * Used in the constructor to create the shape
	 * @return The shape to use
	 */
	private static Shape createShape()
	{
		PolygonShape s = new PolygonShape();
		s.setAsBox(0.3f, 0.3f);
		return s;
	}
	
	public static class ItemObjectTemplate implements ObjectTemplate
	{
		@SuppressWarnings("unchecked")
		@Override
		public GameObject create(ObjectData data)
		{
			if(data.extraData != null && data.extraData.containsKey("itemId"))
			{				
				ItemTemplate template = ItemRegistry.getItemTemplate((String) data.extraData.get("itemId"));
				
				ItemData itemData = new ItemData();
				itemData.name = (String) data.extraData.get("itemId");
				
				itemData.extraData = (Map<String, Object>) data.extraData.getOrDefault("itemData", null);
				
				ItemObject obj = asObject(template.create(itemData));
				if(data.position != null)
					obj.setPosition(data.position);
				obj.setVelocity(data.getOrDef("velocity", Vector2.Zero));
				
				return obj;
			}
			
			return null;
		}
	}
	
	// Getters & Setters //
	
	public Item getItem() { return item; }
	public void setItem(Item i) { this.item = i; }
	
	public Vector2 getVelocity() { return this.velocity; }
	public void setVelocity(Vector2 v) { this.velocity = v; }
}

=== Platform ===
package com.tdcrawl.tdc.objects.staticobjects;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;
import com.badlogic.gdx.physics.box2d.PolygonShape;
import com.tdcrawl.tdc.objects.GameObject;
import com.tdcrawl.tdc.registries.templates.ObjectData;
import com.tdcrawl.tdc.registries.templates.ObjectTemplate;
import com.badlogic.gdx.physics.box2d.Shape;

/**
 * An example object that is basically just a static box that something can stand on
 */
public class Platform extends GameObject
{
	/**
	 * An example object that is basically just a static box that something can stand on
	 * @param shape The shape of the static platform
	 * @param position Where its center point is located
	 * @param friction The friction of it
	 * @param angle What is its angle
	 */
	public Platform(Shape shape, Vector2 position, float friction, float angle)
	{
		super(shape, position, BodyType.StaticBody, 1.0f, 0, friction, angle, false, true, true);
	}
	
	/**
	 * The template for creating a Platform
	 */
	public static class PlatformTemplate implements ObjectTemplate
	{
		@Override
		public GameObject create(ObjectData data)
		{
			PolygonShape shape = new PolygonShape();
			shape.setAsBox(data.dimensions.x, data.dimensions.y);
			
			return new Platform(shape, data.position, data.getOrDef("friction", 0.6f), data.getOrDef("angle", 0));
		}
	}
}

=== Rectangle ===
package com.tdcrawl.tdc.objects.staticobjects;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;
import com.badlogic.gdx.physics.box2d.PolygonShape;
import com.tdcrawl.tdc.objects.GameObject;
import com.tdcrawl.tdc.registries.templates.ObjectData;
import com.tdcrawl.tdc.registries.templates.ObjectTemplate;

/**
 * An example object that is basically just a box
 */
public class Rectangle extends GameObject
{
	/**
	 * An example object that is basically just a box
	 * @param dimensions How big the rectangle is (from the center)
	 * @param position Where its center point is located
	 * @param density How dense it is
	 * @param restitution How bouncy it is
	 * @param friction The friction of it
	 * @param angle What is its angle
	 */
	public Rectangle(Vector2 dimensions, Vector2 position, float density, float restitution, float friction, float angle)
	{
		super(null, position, BodyType.DynamicBody, density, restitution, friction, angle, false, false, true);
		
		PolygonShape shape = new PolygonShape();
		shape.setAsBox(dimensions.x, dimensions.y);
		setShape(shape);
	}
	
	/**
	 * The template for making a Cube object
	 */
	public static class CubeTemplate implements ObjectTemplate
	{
		@Override
		public GameObject create(ObjectData data)
		{
			return new Rectangle(data.dimensions, data.position, data.getOrDef("density", 5.0f), 
									data.getOrDef("restitution", 0.1f), data.getOrDef("friction", 0.1f), data.getOrDef("angle", 0));
		}
	}
}

=== DefaultCollisionHandler ===
package com.tdcrawl.tdc.physics;

import com.badlogic.gdx.physics.box2d.Contact;
import com.badlogic.gdx.physics.box2d.ContactImpulse;
import com.badlogic.gdx.physics.box2d.ContactListener;
import com.badlogic.gdx.physics.box2d.Manifold;
import com.tdcrawl.tdc.events.EventsHandler;
import com.tdcrawl.tdc.events.types.CollisionEvent;
import com.tdcrawl.tdc.events.types.CollisionEvent.CollisionState;
import com.tdcrawl.tdc.objects.GameObject;
import com.tdcrawl.tdc.objects.fixtures.ObjectFixture;

public class DefaultCollisionHandler implements ContactListener
{
	@Override
	public void beginContact(Contact contact)
	{
		if(contact.getFixtureA().getBody().getUserData() instanceof GameObject && 
				contact.getFixtureB().getBody().getUserData() instanceof GameObject)
		{
			// Checks if it's 2 game objects colliding, and if it is call a new event
			
			GameObject obj1 = (GameObject) contact.getFixtureA().getBody().getUserData();
			GameObject obj2 = (GameObject) contact.getFixtureB().getBody().getUserData();
			
			ObjectFixture fix1 = (ObjectFixture) contact.getFixtureA().getUserData();
			ObjectFixture fix2 = (ObjectFixture) contact.getFixtureB().getUserData();
			
			EventsHandler.call(new CollisionEvent(obj1, obj2, fix1, fix2, CollisionState.BEGIN_COLLISION));
		}
	}
	
	@Override
	public void endContact(Contact contact)
	{
		if(contact.getFixtureA().getBody().getUserData() instanceof GameObject && 
				contact.getFixtureB().getBody().getUserData() instanceof GameObject)
		{
			// Checks if it's 2 game objects colliding, and if it is call a new event
			
			GameObject obj1 = (GameObject) contact.getFixtureA().getBody().getUserData();
			GameObject obj2 = (GameObject) contact.getFixtureB().getBody().getUserData();
			
			ObjectFixture fix1 = (ObjectFixture) contact.getFixtureA().getUserData();
			ObjectFixture fix2 = (ObjectFixture) contact.getFixtureB().getUserData();
			
			EventsHandler.call(new CollisionEvent(obj1, obj2, fix1, fix2, CollisionState.END_COLLISION));
		}
	}
	
	// The below methods are just weird and are called in between the two methods above.
	
	@Override
	public void preSolve(Contact contact, Manifold oldManifold)
	{
		
	}
	
	@Override
	public void postSolve(Contact contact, ContactImpulse impulse)
	{
		
	}
}

=== ItemRegistry ===
package com.tdcrawl.tdc.registries;

import java.util.HashMap;
import java.util.Map;

import com.tdcrawl.tdc.registries.templates.ItemTemplate;

public class ItemRegistry
{
	/**
	 * Every object in the game corresponding with its ID
	 */
	private static Map<String, ItemTemplate> templates = new HashMap<>();
	
	/**
	 * Registers an object template with it's given ID
	 * @param id The ID to reference the object by
	 * @param template The template for creating the object
	 * @return true if no object with that ID is present, false if not (and it will not be registered)
	 */
	public static boolean registerObject(String id, ItemTemplate template)
	{
		if(templates.containsKey(id))
			return false;
		templates.put(id, template);
		return true;
	}
	
	/**
	 * Gets the object template from a given ID
	 * @param id The ID to get it from
	 * @return The ObjectTemplate registered with that ID
	 */
	public static ItemTemplate getItemTemplate(String id)
	{
		return templates.get(id);
	}
	
	/**
	 * Removes an object based off its ID
	 * @param id The ID & object to remove
	 * @return The removed object
	 */
	public static ItemTemplate removeObject(String id)
	{
		return templates.remove(id);
	}
}

=== ObjectRegistry ===
package com.tdcrawl.tdc.registries;

import java.util.HashMap;
import java.util.Map;

import com.tdcrawl.tdc.registries.templates.ObjectTemplate;

/**
 * Stores every object in the game corresponding with a given ID so it can be identified and created from just a String ID
 */
public class ObjectRegistry
{
	/**
	 * Every object in the game corresponding with its ID
	 */
	private static Map<String, ObjectTemplate> templates = new HashMap<>();
	
	/**
	 * Registers an object template with it's given ID
	 * @param id The ID to reference the object by
	 * @param template The template for creating the object
	 * @return true if no object with that ID is present, false if not (and it will not be registered)
	 */
	public static boolean registerObject(String id, ObjectTemplate template)
	{
		if(templates.containsKey(id))
			return false;
		templates.put(id, template);
		return true;
	}
	
	/**
	 * Gets the object template from a given ID
	 * @param id The ID to get it from
	 * @return The ObjectTemplate registered with that ID
	 */
	public static ObjectTemplate getObject(String id)
	{
		return templates.get(id);
	}
	
	/**
	 * Removes an object based off its ID
	 * @param id The ID & object to remove
	 * @return The removed object
	 */
	public static ObjectTemplate removeObject(String id)
	{
		return templates.remove(id);
	}
}

=== ItemData ===
package com.tdcrawl.tdc.registries.templates;

import java.util.Map;

public class ItemData
{
	public String name;
	public Map<String, Object> extraData;
}

=== ItemTemplate ===
package com.tdcrawl.tdc.registries.templates;

import com.tdcrawl.tdc.items.Item;

public interface ItemTemplate
{
	/**
	 * Creates a GameObject object based off the given data
	 * @param data The data to base the object off of
	 * @return The uninitialized GameObject or null if there was an error parsing the data
	 */
	public Item create(ItemData data);
}

=== ObjectData ===
package com.tdcrawl.tdc.registries.templates;

import java.util.Map;

import com.badlogic.gdx.math.Vector2;

/**
 * A simple class that just contains some data for objects
 * Everything is public in this because this is basically just a struct (see https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/struct)
 * so there is no point to making getters and setters for it
 */
public class ObjectData implements Cloneable
{
	public String name;
	public Vector2 position;
	public Vector2 dimensions;
	public float radius;
	public Map<String, Object> extraData;
	
	public float getOrDef(String key, float def)
	{
		if(extraData == null)
			return def;
		try
		{
			return Float.parseFloat((String)extraData.getOrDefault(key, def + ""));
		}
		catch(NumberFormatException ex)
		{
			return def;
		}
	}

	public Vector2 getOrDef(String key, Vector2 def)
	{
		if(extraData == null)
			return def;
		try
		{
			if(extraData.containsKey(key))
			{
				// It looks like this: (x,y) - aka (0.0,0.0)
				
				String[] split =("" + extraData.get(key)).split(",");
				return new Vector2(Float.parseFloat(split[0].substring(1) + "f"),
									Float.parseFloat(split[1].substring(0, split[1].length() - 1) + "f"));
			}
			else
				return def;
		}
		catch(Exception ex)
		{
			return def;
		}
	}
	
	public boolean getOrDef(String key, boolean def)
	{
		if(extraData == null)
			return def;
		try
		{
			return Boolean.parseBoolean("" + extraData.get(key));
		}
		catch(Exception ex)
		{
			return def;
		}
	}
	
	public ObjectData clone()
	{
		ObjectData d = new ObjectData();
		d.name = name;
		d.position = position != null ? position.cpy() : null;
		d.dimensions = dimensions != null ? dimensions.cpy() : null;
		d.radius = radius;
		d.extraData = extraData;
		return d;
	}
}

=== ObjectTemplate ===
package com.tdcrawl.tdc.registries.templates;

import com.tdcrawl.tdc.objects.GameObject;

/**
 * Tells how a given object should be created based off certain parameters
 * The same ObjectTemplate may be used to create multiple different objects with different parameters, so try to avoid having instance variables
 */
public interface ObjectTemplate
{
	/**
	 * Creates a GameObject object based off the given data
	 * @param data The data to base the object off of
	 * @return The uninitialized GameObject or null if there was an error parsing the data
	 */
	public GameObject create(ObjectData data);
}

=== GameScreen ===
package com.tdcrawl.tdc.screens;

import java.io.IOException;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.physics.box2d.Box2DDebugRenderer;
import com.tdcrawl.tdc.levels.Level;
import com.tdcrawl.tdc.util.Helper;
import com.tdcrawl.tdc.util.Reference;

public class GameScreen implements Screen
{	
	private Box2DDebugRenderer debugRenderer = new Box2DDebugRenderer();
	private OrthographicCamera cam = new OrthographicCamera();
	
	private Level level;
	
	@Override
	public void show()
	{
		resize(Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
		
		try
		{
			level = new Level(0);
		}
		catch (IOException e)
		{
			e.printStackTrace();
			System.exit(1);
		}
		
		level.create();
	}

	@Override
	public void render(float delta)
	{
		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
		
		if(Reference.isDebug() && Gdx.input.isKeyJustPressed(Keys.F1))
			throw new RuntimeException("User-called crash.");
		
		level.tick(delta, cam);
		
		level.render(delta, cam, debugRenderer);
	}

	@Override
	public void resize(int width, int height)
	{
		// width and height are in px, so convert them to meters then adjust camera
		cam = new OrthographicCamera(Helper.pxToM(width), Helper.pxToM(height));
		cam.zoom = Math.min(720f / width, 480f / height);
		cam.update();
	}

	@Override
	public void pause()
	{
		
	}

	@Override
	public void resume()
	{
		
	}

	@Override
	public void hide()
	{
		
	}

	@Override
	public void dispose()
	{
		level.dispose();
	}
}

=== MainMenuScreen ===
package com.tdcrawl.tdc.screens;

import com.badlogic.gdx.Screen;

public class MainMenuScreen implements Screen
{
	/**
	 * TODO: make
	 */
	
	@Override
	public void show()
	{
		
	}

	@Override
	public void render(float delta)
	{
		
	}

	@Override
	public void resize(int width, int height)
	{
		
	}

	@Override
	public void pause()
	{
		
	}

	@Override
	public void resume()
	{
		
	}

	@Override
	public void hide()
	{
		
	}

	@Override
	public void dispose()
	{
		
	}
}

=== Helper ===
package com.tdcrawl.tdc.util;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.badlogic.gdx.graphics.Camera;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.ChainShape;
import com.badlogic.gdx.physics.box2d.CircleShape;
import com.badlogic.gdx.physics.box2d.EdgeShape;
import com.badlogic.gdx.physics.box2d.Fixture;
import com.badlogic.gdx.physics.box2d.PolygonShape;
import com.badlogic.gdx.physics.box2d.Shape;
import com.badlogic.gdx.physics.box2d.World;
import com.tdcrawl.tdc.events.EventsHandler;
import com.tdcrawl.tdc.events.types.WorldLockChangeEvent;
import com.tdcrawl.tdc.joints.ObjectJoint;
import com.tdcrawl.tdc.objects.GameObject;
import com.tdcrawl.tdc.objects.fixtures.ObjectFixture;

public final class Helper
{
	public static final float PX_TO_M = 32.0f; // 32 pixels for every meter
	
	private static boolean worldLocked = false;
	
	private static List<ObjectFixture> fixturesToRemove = new ArrayList<>();
	private static Map<ObjectFixture, GameObject> fixturesToAdd = new HashMap<>();
	
	private static List<ObjectJoint> jointsToRemove = new ArrayList<>();
	private static List<ObjectJoint> jointsToAdd = new ArrayList<>();
	
	private static List<GameObject> objectsToRemove = new ArrayList<>();
	private static Map<GameObject, World> objectsToAdd = new HashMap<>();
	
	/**
	 * Moves a shape based on the amount of change (it just adds its position to the change amount)
	 * @param s The shape to move
	 * @param change The amount to move it by
	 */
	public static void moveShape(Shape s, Vector2 change)
	{
		if(s instanceof CircleShape)
		{
			CircleShape shape = (CircleShape)s;
			shape.setPosition(shape.getPosition().add(change)); // That was easy
		}
		else if(s instanceof PolygonShape)
		{
			PolygonShape shape = (PolygonShape)s;
			
			int vertexAmt = shape.getVertexCount();
			Vector2[] vertexes = new Vector2[vertexAmt];
			
			for(int i = 0; i < vertexAmt; i++)
			{
				Vector2 vertex = new Vector2();
				shape.getVertex(i, vertex); // Updates the vertex to the actual vertex
				vertexes[i] = vertex.add(change);
			}
			
			shape.set(vertexes);
		}
		else if(s instanceof ChainShape)
		{
			ChainShape shape = (ChainShape)s;
			
			boolean isLooped = shape.isLooped();
			
			int vertexAmt = shape.getVertexCount();
			Vector2[] vertexes = new Vector2[vertexAmt];
			
			for(int i = 0; i < vertexAmt; i++)
			{
				Vector2 vertex = new Vector2();
				shape.getVertex(i, vertex); // Updates the vertex to the actual vertex
				vertexes[i] = vertex.add(change);
			}
			
			// The only way to move this is to make a new one
			shape = new ChainShape();
			if(isLooped)
				shape.createLoop(vertexes);
			else
				shape.createChain(vertexes);
		}
		else if(s instanceof EdgeShape)
		{
			EdgeShape shape = (EdgeShape)s;
			
			Vector2 temp = new Vector2();
			
			shape.getVertex0(temp);
			temp.add(change);
			shape.setVertex0(temp);
			
			shape.getVertex3(temp);
			temp.add(change);
			shape.setVertex3(temp);
		}
	}
	
	public static Vector2 clamp(Vector2 vec, float xMin, float yMin, float xMax, float yMax)
	{
		if(vec.x < xMin)
			vec.x = xMin;
		else if(vec.x > xMax)
			vec.x = xMax;
		if(vec.y < yMin)
			vec.y = yMin;
		else if(vec.y > yMax)
			vec.y = yMax;
		return vec;
	}
	
	public static float randomizer(float baseValue, float range)
	{
		float value = (float) (Math.random() * range + baseValue);
		return value;
	}
	
	public static Vector2 clamp(Vector2 vec, Vector2 min, Vector2 max)
	{
		return clamp(vec, min.x, min.y, max.x, max.y);
	}
	
	public static double clamp(double var, double min, double max)
	{
		if(var < min) return min;
		if(var > max) return max;
		return var;
	}
	
	public static double clamp(float var, float min, float max)
	{
		if(var < min) return min;
		if(var > max) return max;
		return var;
	}
	
	public static double clamp(int var, int min, int max)
	{
		if(var < min) return min;
		if(var > max) return max;
		return var;
	}
	
	public static float pxToM(float px)
	{
		return px / PX_TO_M;
	}
	
	public static float mToPx(float m)
	{
		return m * PX_TO_M;
	}
	
	public static int toInt(boolean b)
	{
		return b ? 1 : 0;
	}
	
	public static Vector2 clone(Vector2 c)
	{
		return new Vector2(c.x, c.y);
	}
	
	public static float angleTo(float x1, float y1, float x2, float y2)
	{
		return angleTo(new Vector2(x1, y1), new Vector2(x2, y2));
	}
	
	public static float angleTo(Vector2 x, Vector2 y)
	{
		return angleTo(x, y, Vector2.Zero);
	}
	
	public static float angleTo(Vector2 x, Vector2 y, Vector2 offset)
	{
		return new Vector2(y).sub(new Vector2(x)).add(offset).angleRad();
	}

	public static void removeFixture(ObjectFixture f)
	{
		if(isWorldLocked())
			fixturesToRemove.add(f);
		else
			f.remove();
	}
	
	public static void addFixture(ObjectFixture f, GameObject gameObject)
	{
		if(isWorldLocked())
			fixturesToAdd.put(f, gameObject);
		else
			f.init(gameObject.getBody());
	}
	
	public static void removeJoint(ObjectJoint joint)
	{
		if(isWorldLocked())
			jointsToRemove.add(joint);
		else
			joint.detatch();
	}

	public static void addJoint(ObjectJoint joint) 
	{
		if(isWorldLocked())
			jointsToAdd.add(joint);
		else
			joint.attach();
	}
	
	public static void addObject(GameObject obj, World world)
	{
		if(isWorldLocked())
			objectsToAdd.put(obj, world);
		else
			obj.init(world);
	}
	
	public static void removeObject(GameObject obj)
	{
		if(isWorldLocked())
		{
			objectsToRemove.add(obj);
		}
		else if(obj.getBody() != null)
		{
			obj.getWorld().destroyBody(obj.getBody());
			obj.setBody(null);
		}
	}
	
	public static void cleanup()
	{
		if(!isWorldLocked())
		{
			while(fixturesToRemove.size() != 0)
			{
				ObjectFixture f = fixturesToRemove.remove(fixturesToRemove.size() - 1);
				if(fixturesToAdd.containsKey(f))
					fixturesToAdd.remove(f);
				else
					removeFixture(f);
			}
			
			for(ObjectFixture f : fixturesToAdd.keySet())
			{
				addFixture(f, fixturesToAdd.get(f));
			}
			
			fixturesToAdd.clear();
			
			while(jointsToAdd.size() != 0)
				addJoint(jointsToAdd.remove(jointsToAdd.size() - 1));
			while(jointsToRemove.size() != 0)
				removeJoint(jointsToRemove.remove(jointsToRemove.size() - 1));
			
			for(GameObject obj : objectsToAdd.keySet())
				addObject(obj, objectsToAdd.get(obj));
			
			objectsToAdd.clear();
			
			while(objectsToRemove.size() != 0)
			{
				GameObject obj = objectsToRemove.remove(objectsToRemove.size() - 1);
				removeObject(obj);
			}
		}
		else
			throw new IllegalStateException("cleanup cannot be called when world is locked!");
	}
	
	public static Vector2 screenCoordinatesToMeters(Vector2 coords, Camera cam)
	{
		Vector3 v3 = new Vector3(coords, 0);
		cam.unproject(v3);
		return new Vector2(v3.x, v3.y);
	}
	
	public static void setWorldLocked(boolean b)
	{
		worldLocked = b;
		EventsHandler.call(new WorldLockChangeEvent(isWorldLocked()));
	}
	
	public static boolean isWorldLocked() { return worldLocked; }

	/**
	 * Returns a fancy String for those objects not kind enough to create their on toString() method
	 * @param object The object to stringify (no properties will be changed)
	 * @return A super fancy String descringing that object, but if none can be generated will just use that object's toString
	 */
	public static String toString(Object object)
	{
		if(object instanceof Fixture)
		{
			Fixture f = (Fixture)object;
			
			return "Fixture [density=" + f.getDensity() + ", friction=" + f.getFriction() + ", restitution=" + f.getRestitution() + ", shape=" + toString(f.getShape()) + "]";
		}
		else if(object instanceof Body)
		{
			Body b = (Body)object;
			
			return "Body [position=" + b.getPosition() + ", mass=" + b.getMass() + ", velocity=" + b.getLinearVelocity() + ", type=" + b.getType() + ", localCenter=" + b.getLocalCenter() + "]";
		}
		
		return object != null ? object.toString() : "null";
	}

	public static void flipX(PolygonShape armShape)
	{
		int len = armShape.getVertexCount();
		Vector2[] vertexes = new Vector2[len];
		
		for(int i = 0; i < len; i++)
		{
			Vector2 vertex = new Vector2();
			armShape.getVertex(i, vertex);
			vertex.x = -vertex.x;
			vertexes[i] = vertex;
		}
		
		armShape.set(vertexes);
	}
}

=== Reference ===
package com.tdcrawl.tdc.util;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Calendar;
import java.util.GregorianCalendar;

import com.badlogic.gdx.utils.Logger;

public final class Reference
{
	public static boolean isDebug() { return true; };
	
	public static final int WINDOW_WIDTH = 720;
	public static final int WINDOW_HEIGHT = 480;
	public static final int FPS = 60;
	public static final String NAME = "The Dungeon Crawl";
	
	private static Logger debugLogger = new Logger("debug", Logger.DEBUG);
	private static Logger defaultLogger = new Logger("log", Logger.INFO);
	
	public static void handleError(Throwable ex)
	{
		Calendar cal = new GregorianCalendar();
		cal.setTimeInMillis(System.currentTimeMillis());
		
		String fileName = "crash report - " + cal.get(Calendar.MONTH) + "-" + cal.get(Calendar.DATE) + "-" + cal.get(Calendar.YEAR) + "_" + 
												cal.get(Calendar.HOUR_OF_DAY) + "-" + cal.get(Calendar.MINUTE) + "-" + cal.get(Calendar.SECOND) + ".txt";
		
		new File("crashes/").mkdirs();
		
		StringBuilder messageBuilder = new StringBuilder();
		messageBuilder.append(ex.toString() + System.lineSeparator());
		
		for(StackTraceElement e : ex.getStackTrace())
		{
			messageBuilder.append("\tat " + e + System.lineSeparator());
		}
		
		String message = messageBuilder.toString();
		
		try
		{
			BufferedWriter bw = new BufferedWriter(new FileWriter("crashes/" + fileName));
			bw.write(message);
			bw.close();
			
			ex.printStackTrace();
			
			System.err.println("Crash report saved to crashes/" + fileName);
		}
		catch (IOException ioEx)
		{
			System.err.println("UNABLE TO SAVE CRASH REPORT!");
			System.err.println("Saving error:");
			ioEx.printStackTrace();
			System.err.println("Crash report:");
			ex.printStackTrace();
		}
		
		System.exit(1);
	}

	public static void debugLog(String string, Object obj)
	{
		if(obj == null)
			debugLog("null> " + string);
		else
			debugLog(string, obj.getClass());
	}
	
	public static void debugLog(String string, Class<?> clazz)
	{
		debugLog(clazz.getName() + "> " + string);
	}
	
	private static void debugLog(String s)
	{
		debugLogger.info(s);
	}
	
	public static void log(String s)
	{
		defaultLogger.info(s);
	}
}

=== UserDataParser ===
package com.tdcrawl.tdc.util;

import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.Fixture;
import com.tdcrawl.tdc.objects.GameObject;
import com.tdcrawl.tdc.objects.fixtures.ObjectFixture;

public class UserDataParser
{
	public static ObjectFixture getObjectFixture(Fixture f)
	{
		if(f.getUserData() instanceof ObjectFixture)
			return (ObjectFixture)f.getUserData();
		else
			return null;
	}
	
	public static GameObject getGameObject(Body b)
	{
		if(b.getUserData() instanceof GameObject)
			return (GameObject)b.getUserData();
		else
			return null;
	}

}

=== Vector2I ===
package com.tdcrawl.tdc.util;

import com.badlogic.gdx.math.Vector2;

/**
 * Like the {@link Vector2} but for integers
 */
public class Vector2I implements Cloneable
{
	public int x, y;
	
	public static final Vector2I Zero = new Vector2I();
	public static final Vector2I One = new Vector2I(1, 1);
	
	/**
	 * Initializes a Vector2I with both numbers as 0
	 */
	public Vector2I()
	{
		this(0, 0);
	}
	
	/**
	 * Initializes a Vector2I with both numbers the given parameters
	 * @param x The x value
	 * @param y The y value
	 */
	public Vector2I(int x, int y)
	{
		this.x = x;
		this.y = y;
	}
	
	/**
	 * Clones the vector passed in and sets this's values to that
	 * @param v The vector to clone
	 */
	public Vector2I(Vector2I v)
	{
		this(v.x, v.y);
	}
	
	/**
	 * Adds two vectors
	 * @param other The vector to add to this
	 * @return this for chaining
	 */
	public Vector2I add(Vector2I other)
	{
		x += other.x;
		y += other.y;
		return this;
	}
	
	/**
	 * Subtracts two vectors
	 * @param other The vector to add to this
	 * @return this for chaining
	 */
	public Vector2I sub(Vector2I other)
	{
		x -= other.x;
		y -= other.y;
		return this;
	}
	
	/**
	 * Multiplies two vectors
	 * @param other The vector to add to this
	 * @return this for chaining
	 */
	public Vector2I scl(Vector2I other)
	{
		x *= other.x;
		y *= other.y;
		return this;
	}
	
	/**
	 * Multiplies two vectors
	 * @param other The vector to add to this
	 * @return this for chaining
	 */
	public Vector2I mul(Vector2I other)
	{
		return scl(other); // Because who would guess "scl" means multiply?? I sure didn't
	}
	
	/**
	 * Divides two vectors
	 * @param other The vector to add to this
	 * @return this for chaining
	 */
	public Vector2I divide(Vector2I other)
	{
		x /= other.x;
		y /= other.y;
		return this;
	}
	
	/**
	 * Moduluses two vectors
	 * @param other The vector to add to this
	 * @return this for chaining
	 */
	public Vector2I mod(Vector2I other)
	{
		x %= other.x;
		y %= other.y;
		return this;
	}
	
	/**
	 * Averages a bunch of vectors given, or returns 0 if there are none
	 * @param vectors The Vectors to average
	 * @return A Vector containing the x and y average
	 */
	public static Vector2I avg(Vector2I... vectors)
	{
		if(vectors.length == 0)
			return Vector2I.Zero;
		
		Vector2I sum = new Vector2I();
		
		for(Vector2I v : vectors)
			sum.add(v);
		
		return sum.divide(new Vector2I(vectors.length, vectors.length));
	}
	
	@Override
	public String toString()
	{
		return "(" + x + "," + y + ")";
	}
	
	@Override
	public int hashCode()
	{
		final int prime = 31;
		int result = 1;
		result *= prime + x;
		result *= prime + y;
		return result;
	}
	
	@Override
	public boolean equals(Object other)
	{
		if(other instanceof Vector2I)
		{
			Vector2I o = (Vector2I)other;
			return o.x == x && o.y == y;
		}
		return false;
	}
	
	/**
	 * Clones the Vector
	 * <br>See {@link Vector2I#clone()}
	 * @return a clone
	 */
	public Vector2I cpy()
	{
		return new Vector2I(this);
	}
	
	@Override
	public Vector2I clone()
	{
		return cpy();
	}
}
